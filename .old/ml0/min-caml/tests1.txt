10
10.
10.2
a.(2)
-1
-1.
1 + 1
1 - 1
1 +. 1
1 -. 1
1 *. 1
1 /. 1
2 + 3 *. 4
2 + 3 + 4
(2 + 3) *. 4
a = b
a <> b
a <= b
a >= b
a < b
a > b
1 = 1 = true
2. +. 2. = 2. *. 2.
-2.
----0.
----2
2 + -2
2 + -2.
-2 + 2
-2. + 2
hello world
a -b
-a b
f x y -z
-f x y -z
1, 2, 3
a, b, c
2. +. 2. = 2. *. 2., -2. + 2, -f x y -z
a.(1) <- 1
a.(1) <- 1 + 2
a.(1) <- 1 = 2
a.(1) <- 1, 2
a.(0).(1) <- 1
a.(a.(0) <- 1) <- 1
1;2;3
a.(1; 0) <- 1, 2
a.(a.(0) <- 1) <- 1; 2
const () 3.; 4
let x = 2 in x
let (a,b,c) = (1,2,3) in a
let rec const x y = x in const () 3.; 4
let rec ack x y = if x <= 0 then y + 1 else if y <= 0 then ack (x - 1) 1 else ack (x - 1) (ack x (y - 1)) in print_int (ack 3 10)
let rec make_adder x = let rec adder y = x + y in adder in print_int ((make_adder 3) 7)
let rec f x = x + 123 in let rec g y = f in print_int ((g 456) 789)
let rec f n = if n < 0 then () else (print_int n; let a = Array.make 1 f in a.(0) (n - 1)) in f 9
let x = 10 in let rec f y = if y = 0 then 0 else x + f (y - 1) in print_int (f 123)
let rec h p = let (v1,v2,v3,v4,v5,v6,v7,v8,v9,v10) = p in let rec g z = let r = v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8 + v9 + v10 in if z > 0 then r else g (-z) in g 1 in print_int (h (1,2,3,4,5,6,7,8,9,10)); print_newline ()
let t = 123 in let f = 456 in let rec even x = let rec odd x = if x > 0 then even (x - 1) else if x < 0 then even (x + 1) else f in if x > 0 then odd (x - 1) else if x < 0 then odd (x + 1) else t in print_int (even 789)
let rec fib n = if n <= 1 then n else fib (n - 1) + fib (n - 2) in print_int (fib 30)
print_int (int_of_float ((sin (cos (sqrt (abs_float (-12.3)))) +. 4.5 -. 6.7 *. 8.9 /. 1.2) *. float_of_int 1000000))
let rec compose f g = let rec composed x = g (f x) in composed in let rec dbl x = x + x in let rec inc x = x + 1 in let rec dec x = x - 1 in let h = compose inc (compose dbl dec) in print_int (h 123)
let rec gcd m n = if m = 0 then n else if m <= n then gcd m (n - m) else gcd n (m - n) in print_int (gcd 21600 337500)
let rec inprod v1 v2 acc i = if i < 0 then acc else inprod v1 v2 (acc +. v1.(i) *. v2.(i)) (i - 1) in let v1 = Array.make 3 1.2 in let v2 = Array.make 3 4.5 in print_int (truncate (1000000. *. inprod v1 v2 0. 2))
let rec inprod v1 v2 i = if i < 0 then 0.0 else v1.(i) *. v2.(i) +. inprod v1 v2 (i - 1) in let v1 = Array.make 3 1.2 in let v2 = Array.make 3 4.5 in print_int (truncate (1000000. *. inprod v1 v2 2))
let rec getx v = (let (x, y, z) = v in x) in let rec gety v = (let (x, y, z) = v in y) in let rec getz v = (let (x, y, z) = v in z) in let rec inprod v1 v2 = getx v1 *. getx v2 +. gety v1 *. gety v2 +. getz v1 *. getz v2 in print_int (truncate (1000000. *. inprod (1., 2., 3.) (4., 5., 6.)))
let rec f _ = 0 in 0
let rec f _ = 123 in let rec g _ = 456 in let rec h _ = 789 in let x = f () in let y = g () in print_int ((if h () = 0 then x - y else y - x) + x + y)
let rec f _ = 123 in let rec g _ = 456 in let rec h _ = 789 in let x = f () in print_int ((if x <= 0 then g () + x else h () - x) + x)
let rec f _ = 123 in let rec g _ = 456 in let rec h _ = 789 in let x = f () in let y = g () in print_int ((if h () = 0 then x + 1 else y + 2) + x + y)
let rec f _ = 123 in let rec g _ = 456 in let x = f () in print_int ((if x <= 0 then g () + x else x) + x)
let rec f _ = 123 in let rec g _ = 456 in let rec h _ = 789 in let x = f () in print_int ((if x <= 0 then g () else h ()) + x)
let rec loop3 i k j a b c = if k < 0 then () else (c.(i).(j) <- c.(i).(j) +. a.(i).(k) *. b.(k).(j); loop3 i (k - 1) j a b c) in let rec loop2 i m j a b c = if j < 0 then () else (loop3 i (m - 1) j a b c; loop2 i m (j - 1) a b c) in let rec loop1 i m n a b c = if i < 0 then () else (loop2 i m (n - 1) a b c; loop1 (i - 1) m n a b c) in let rec mul l m n a b c = loop1 (l - 1) m n a b c in let dummy = Array.make 0 0. in let rec init i n mat = if i < 0 then () else (mat.(i) <- Array.make n 0.; init (i - 1) n mat) in let rec make m n dummy = let mat = Array.make m dummy in init (m - 1) n mat; mat in let a = make 2 3 dummy in let b = make 3 2 dummy in let c = make 2 2 dummy in a.(0).(0) <- 1.; a.(0).(1) <- 2.; a.(0).(2) <- 3.; a.(1).(0) <- 4.; a.(1).(1) <- 5.; a.(1).(2) <- 6.; b.(0).(0) <- 7.; b.(0).(1) <- 8.; b.(1).(0) <- 9.; b.(1).(1) <- 10.; b.(2).(0) <- 11.; b.(2).(1) <- 12.; mul 2 3 2 a b c; print_int (truncate (c.(0).(0))); print_newline (); print_int (truncate (c.(0).(1))); print_newline (); print_int (truncate (c.(1).(0))); print_newline (); print_int (truncate (c.(1).(1))); print_newline ()
if () then () else let x = () in ()
let rec mul l m n a b c = let rec loop1 i = if i < 0 then () else let rec loop2 j = if j < 0 then () else let rec loop3 k = if k < 0 then () else (c.(i).(j) <- c.(i).(j) +. a.(i).(k) *. b.(k).(j); loop3 (k - 1)) in loop3 (m - 1); loop2 (j - 1) in loop2 (n - 1); loop1 (i - 1) in loop1 (l - 1) in let dummy = Array.make 0 0. in let rec make m n = let mat = Array.make m dummy in let rec init i = if i < 0 then () else (mat.(i) <- Array.make n 0.; init (i - 1)) in init (m - 1); mat in let a = make 2 3 in let b = make 3 2 in let c = make 2 2 in a.(0).(0) <- 1.; a.(0).(1) <- 2.; a.(0).(2) <- 3.; a.(1).(0) <- 4.; a.(1).(1) <- 5.; a.(1).(2) <- 6.; b.(0).(0) <- 7.; b.(0).(1) <- 8.; b.(1).(0) <- 9.; b.(1).(1) <- 10.; b.(2).(0) <- 11.; b.(2).(1) <- 12.; mul 2 3 2 a b c; print_int (truncate (c.(0).(0))); print_newline (); print_int (truncate (c.(0).(1))); print_newline (); print_int (truncate (c.(1).(0))); print_newline (); print_int (truncate (c.(1).(1))); print_newline ()
print_int (if z < 0 then y else x)
print_int ((if z < 0 then y else x) + (if x > 0 then z else y) + (if y < 0 then x else z))
let z = truncate (-.7.8) in print_int ((if z < 0 then y else x) + (if x > 0 then z else y) + (if y < 0 then x else z))
let x = truncate 1.2 in let y = truncate 4.5 in let z = truncate (-.7.8) in print_int ((if z < 0 then y else x) + (if x > 0 then z else y) + (if y < 0 then x else z))
let rec f _ = 12345 in let y = Array.make 10 3 in let x = 67890 in print_int (if y.(0) = 3 then f () + y.(1) + x else 7)
print_int 123; print_int (-456); print_int (789+0)
let rec foo a b c d e f = print_int a; print_int b; print_int c; print_int d; print_int e; print_int f in let rec bar a b c d e f = foo b a d e f c in bar 1 2 3 4 5 6
let rec f a b c d = let e = a + b in let f = a + c in let g = a + d in let h = b + c in let i = b + d in let j = c + d in let k = e + f in let l = e + g in let m = e + h in let n = e + i in let o = e + j in let p = f + g in let q = f + h in let r = f + i in let s = f + j in let t = g + h in let u = g + i in let v = g + j in let w = h + i in let x = h + j in let y = i + j in let aa = k + l in let ab = k + m in let ac = k + n in let ad = k + o in let ae = k + p in let af = k + q in let ag = k + r in let ah = k + s in let ai = k + t in let aj = k + u in let ak = k + v in let al = k + w in let am = k + x in let an = k + y in let z = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q + r + s + t + u + v + w + x + y + aa + ab + ac + ad + ae + af + ag + ah + ai + aj + ak + al + am + an in -z in print_int (f 1 2 3 4)
let rec f _ = 12345 in let rec g y = y + 1 in let z = Array.make 10 1 in let x = f () in let y = 67890 in let z0 = z.(0) in let z1 = z0 + z0 in let z2 = z1 + z1 in let z3 = z2 + z2 in let z4 = z3 + z3 in let z5 = z4 + z4 in let z6 = z5 + z5 in let z7 = z6 + z6 in let z8 = z7 + z7 in let z9 = z8 + z8 in let z10 = z9 + z9 in let z11 = z10 + z10 in let z12 = z11 + z11 in let z13 = z12 + z12 in let z14 = z13 + z13 in let z15 = z14 + z14 in print_int (if z.(1) = 0 then g y else z0 + z1 + z2 + z3 + z4 + z5 + z6 + z7 + z8 + z9 + z10 + z11 + z12 + z13 + z14 + z15 + x)
let rec f x0 = let x1 = x0 + 1 in let x2 = x1 + 1 in let x3 = x2 + 1 in let x4 = x3 + 1 in let x5 = x4 + 1 in let x6 = x5 + 1 in let x7 = x6 + 1 in let x8 = x7 + 1 in let x9 = x8 + 1 in let x10 = x9 + 1 in let x11 = x10 + 1 in let x12 = x11 + 1 in let x13 = x12 + 1 in let x14 = x13 + 1 in let x15 = x14 + 1 in let x16 = x15 + 1 in let x17 = x16 + 1 in let x18 = x17 + 1 in let x19 = x18 + x1 in let x20 = x19 + x2 in let x21 = x20 + x3 in let x22 = x21 + x4 in let x23 = x22 + x5 in let x24 = x23 + x6 in let x25 = x24 + x7 in let x26 = x25 + x8 in let x27 = x26 + x9 in let x28 = x27 + x10 in let x29 = x28 + x11 in let x30 = x29 + x12 in let x31 = x30 + x13 in let x32 = x31 + x14 in let x33 = x32 + x15 in let x34 = x33 + x16 in let x35 = x34 + x17 in let x36 = x35 + x0 in x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x0 in print_int (f 0)
let rec sum acc x = if x <= 0 then acc else sum (acc + x) (x - 1) in print_int (sum 0 10000)
let rec sum x = if x <= 0 then 0 else sum (x - 1) + x in print_int (sum 10000)
let x = 42 in let rec f y1 y2 y3 y4 y5 = print_int (x + y1 + y2 + y3 + y4 + y5) in f 1 2 3 4 5
let x = 42 in let rec f y1 y2 y3 y4 y5 y6 = print_int x in f 1 2 3 4 5 6
let rec xor x y = if x then not y else y in let rec fsqr x = x *. x in let rec fhalf x = x /. 2. in let rec o_texturetype m = let (m_tex, xm_shape, xm_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_tex in let rec o_form m = let (xm_tex, m_shape, xm_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_shape in let rec o_reflectiontype m = let (xm_tex, xm_shape, m_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_surface in let rec o_isinvert m = let (m_tex, m_shape, m_surface, m_isrot, xm_abc, xm_xyz, m_invert, xm_surfparams, xm_color, xm_rot123) = m in m_invert in let rec o_isrot m = let (xm_tex, xm_shape, xm_surface, m_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_isrot in let rec o_param_a m = let (xm_tex, xm_shape, xm_surface, xm_isrot, m_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_abc.(0) in let rec o_param_b m = let (xm_tex, xm_shape, xm_surface, xm_isrot, m_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_abc.(1) in let rec o_param_c m = let (xm_tex, xm_shape, xm_surface, xm_isrot, m_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_abc.(2) in let rec o_param_x m = let (xm_tex, xm_shape, xm_surface, xm_isrot, xm_abc, m_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_xyz.(0) in let rec o_param_y m = let (xm_tex, xm_shape, xm_surface, xm_isrot, xm_abc, m_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_xyz.(1) in let rec o_param_z m = let (xm_tex, xm_shape, xm_surface, xm_isrot, xm_abc, m_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_xyz.(2) in let rec o_diffuse m = let (xm_tex, xm_shape, xm_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, m_surfparams, xm_color, xm_rot123) = m in m_surfparams.(0) in let rec o_hilight m = let (xm_tex, xm_shape, xm_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, m_surfparams, xm_color, xm_rot123) = m in m_surfparams.(1) in let rec o_color_red m = let (xm_tex, xm_shape, m_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, m_color, xm_rot123) = m in m_color.(0) in let rec o_color_green m = let (xm_tex, xm_shape, m_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, m_color, xm_rot123) = m in m_color.(1) in let rec o_color_blue m = let (xm_tex, xm_shape, m_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, m_color, xm_rot123) = m in m_color.(2) in let rec o_param_r1 m = let (xm_tex, xm_shape, xm_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, m_rot123) = m in m_rot123.(0) in let rec o_param_r2 m = let (xm_tex, xm_shape, xm_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, m_rot123) = m in m_rot123.(1) in let rec o_param_r3 m = let (xm_tex, xm_shape, xm_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, m_rot123) = m in m_rot123.(2) in let rec normalize_vector v inv = let n0 = (sqrt (fsqr v.(0) +. fsqr v.(1) +. fsqr v.(2))) in let n = if inv then -.n0 else n0 in v.(0) <- v.(0) /. n; v.(1) <- v.(1) /. n; v.(2) <- v.(2) /. n in let rec sgn x = if 0.0 < x then 1.0 else -1.0 in let rec rad x = x *. (0.0) in let rec read_environ _ = screen.(0) <- read_float (); screen.(1) <- read_float (); screen.(2) <- read_float (); let v1 = rad (read_float ()) in cos_v.(0) <- cos v1; sin_v.(0) <- sin v1; let v2 = rad (read_float ()) in cos_v.(1) <- cos v2; sin_v.(1) <- sin v2; let nl = read_float () in let l1 = rad (read_float ()) in let sl1 = sin l1 in light.(1) <- -.sl1; let l2 = rad (read_float ()) in let cl1 = cos l1 in let sl2 = sin l2 in light.(0) <- cl1 *. sl2; let cl2 = cos l2 in light.(2) <- cl1 *. cl2; beam.(0) <- read_float (); vp.(0) <- cos_v.(0) *. sin_v.(1) *. (-200.0); vp.(1) <- (-.sin_v.(0)) *. (-200.0); vp.(2) <- cos_v.(0) *. cos_v.(1) *. (-200.0); view.(0) <- vp.(0) +. screen.(0); view.(1) <- vp.(1) +. screen.(1); view.(2) <- vp.(2) +. screen.(2) in let rec read_nth_object n = let texture = read_int () in if texture <> -1 then ( let form = read_int () in let refltype = read_int () in let isrot_p = read_int () in let abc = Array.make 3 0.0 in abc.(0) <- read_float (); abc.(1) <- read_float (); abc.(2) <- read_float (); let xyz = Array.make 3 0.0 in xyz.(0) <- read_float (); xyz.(1) <- read_float (); xyz.(2) <- read_float (); let m_invert = 0.0 > (read_float ()) in let reflparam = Array.make 2 0.0 in reflparam.(0) <- read_float (); reflparam.(1) <- read_float (); let color = Array.make 3 0.0 in color.(0) <- read_float (); color.(1) <- read_float (); color.(2) <- read_float (); let rotation = Array.make 3 0.0 in if isrot_p <> 0 then ( rotation.(0) <- rad (read_float ()); rotation.(1) <- rad (read_float ()); rotation.(2) <- rad (read_float ()) ) else (); let m_invert2 = if form = 2 then true else m_invert in let obj = (texture, form, refltype, isrot_p, abc, xyz, m_invert2, reflparam, color, rotation ) in objects.(n) <- obj; if form = 3 then ( let a = abc.(0) in abc.(0) <- if 0.0 = a then 0.0 else (sgn a) /. (fsqr a); let b = abc.(1) in abc.(1) <- if 0.0 = b then 0.0 else (sgn b) /. (fsqr b); let c = abc.(2) in abc.(2) <- if 0.0 = c then 0.0 else (sgn c) /. (fsqr c)) else if form = 2 then normalize_vector abc (not m_invert) else (); if isrot_p <> 0 then ( cs_temp.(10) <- cos rotation.(0); cs_temp.(11) <- sin rotation.(0); cs_temp.(12) <- cos rotation.(1); cs_temp.(13) <- sin rotation.(1); cs_temp.(14) <- cos rotation.(2); cs_temp.(15) <- sin rotation.(2); cs_temp.(0) <- cs_temp.(12) *. cs_temp.(14); cs_temp.(1) <- (cs_temp.(11) *. cs_temp.(13) *. cs_temp.(14)) -. (cs_temp.(10) *. cs_temp.(15)); cs_temp.(2) <-        (cs_temp.(10) *. cs_temp.(13) *. cs_temp.(14)) +. (cs_temp.(11) *. cs_temp.(15)); cs_temp.(3) <-        cs_temp.(12) *. cs_temp.(15); cs_temp.(4) <-        (cs_temp.(11) *. cs_temp.(13) *. cs_temp.(15)) +. (cs_temp.(10) *. cs_temp.(14)); cs_temp.(5) <-        (cs_temp.(10) *. cs_temp.(13) *. cs_temp.(15)) -. (cs_temp.(11) *. cs_temp.(14)); cs_temp.(6) <-        -.cs_temp.(13); cs_temp.(7) <-        cs_temp.(11) *. cs_temp.(12); cs_temp.(8) <-        cs_temp.(10) *. cs_temp.(12); let ao = abc.(0) in let bo = abc.(1) in let co = abc.(2) in abc.(0) <- ao *. fsqr cs_temp.(0) +. bo *. fsqr cs_temp.(3) +. co *. fsqr cs_temp.(6); abc.(1) <- ao *. fsqr cs_temp.(1) +. bo *. fsqr cs_temp.(4) +. co *. fsqr cs_temp.(7); abc.(2) <- ao *. fsqr cs_temp.(2) +. bo *. fsqr cs_temp.(5) +. co *. fsqr cs_temp.(8); rotation.(0) <- 2.0 *. (ao *. cs_temp.(1) *. cs_temp.(2) +. bo *. cs_temp.(4) *. cs_temp.(5) +. co *. cs_temp.(7) *. cs_temp.(8)); rotation.(1) <- 2.0 *. (ao *. cs_temp.(0) *. cs_temp.(2) +. bo *. cs_temp.(3) *. cs_temp.(5) +. co *. cs_temp.(6) *. cs_temp.(8)); rotation.(2) <- 2.0 *. (ao *. cs_temp.(0) *. cs_temp.(1) +. bo *. cs_temp.(3) *. cs_temp.(4) +. co *. cs_temp.(6) *. cs_temp.(7))) else (); true) else false in let rec read_object n = if n < 61 then if read_nth_object n then read_object (n + 1) else () else () in let rec read_all_object _ = read_object 0 in let rec read_net_item length = let item = read_int () in if item = -1 then Array.make (length + 1) (-1) else let v = read_net_item (length + 1) in (v.(length) <- item; v) in let rec read_or_network length = let net = read_net_item 0 in if net.(0) = -1 then Array.make (length + 1) net else let v = read_or_network (length + 1) in (v.(length) <- net; v) in let rec read_and_network n = let net = read_net_item 0 in if net.(0) = -1 then () else ( and_net.(n) <- net; read_and_network (n + 1)) in let rec read_parameter _ = ( read_environ (); read_all_object (); read_and_network 0; or_net.(0) <- read_or_network 0) in let rec solver_rect m l = let answera = if 0.0 = l.(0) then false else ( let d = if xor (o_isinvert m) (0.0 > l.(0)) then (o_param_a m) else -.(o_param_a m) in let d2 = (d -. solver_w_vec.(0)) /. l.(0) in if abs_float (d2 *. l.(1) +. solver_w_vec.(1)) < o_param_b m then if abs_float (d2 *. l.(2) +. solver_w_vec.(2)) < o_param_c m then (solver_dist.(0) <- d2; true) else false else false) in if answera then 1 else let answerb = if 0.0 = l.(1) then false else ( let d = if xor (o_isinvert m) (0.0 > l.(1)) then (o_param_b m) else -.(o_param_b m) in let d2 = (d -. solver_w_vec.(1)) /. l.(1) in if abs_float (d2 *. l.(2) +. solver_w_vec.(2)) < o_param_c m then if abs_float (d2 *. l.(0) +. solver_w_vec.(0)) < o_param_a m then (solver_dist.(0) <- d2; true) else false else false) in if answerb then 2 else let answerc = if 0.0 = l.(2) then false else ( let d = if xor (o_isinvert m) (0.0 > l.(2)) then (o_param_c m) else -.(o_param_c m) in let d2 = (d -. solver_w_vec.(2)) /. l.(2) in if abs_float (d2 *. l.(0) +. solver_w_vec.(0)) < o_param_a m then if abs_float (d2 *. l.(1) +. solver_w_vec.(1)) < o_param_b m then (solver_dist.(0) <- d2; true) else false else false) in if answerc then 3 else 0 in ()
let rec solver_surface m l = let q = (l.(0) *. o_param_a m +. l.(1) *. o_param_b m +. l.(2) *. o_param_c m) in if 0.0 < q then let t = (solver_w_vec.(0) *. o_param_a m +. solver_w_vec.(1) *. o_param_b m +. solver_w_vec.(2) *. o_param_c m) /. q in (solver_dist.(0) <- -.t; 1) else 0 in let rec in_prod_sqr_obj m v = ((fsqr v.(0)) *. o_param_a m +. (fsqr v.(1)) *. o_param_b m +. (fsqr v.(2)) *. o_param_c m) in let rec in_prod_co_objrot m v = v.(1) *. v.(2) *. o_param_r1 m +. v.(0) *. v.(2) *. o_param_r2 m +. v.(0) *. v.(1) *. o_param_r3 m in let rec solver2nd_mul_b m l = solver_w_vec.(0) *. l.(0) *. o_param_a m +. solver_w_vec.(1) *. l.(1) *. o_param_b m +. solver_w_vec.(2) *. l.(2) *. o_param_c m in let rec solver2nd_rot_b m l = (solver_w_vec.(2) *. l.(1) +. solver_w_vec.(1) *. l.(2)) *. o_param_r1 m +. (solver_w_vec.(0) *. l.(2) +. solver_w_vec.(2) *. l.(0)) *. o_param_r2 m +. (solver_w_vec.(0) *. l.(1) +. solver_w_vec.(1) *. l.(0)) *. o_param_r3 m in let rec solver_second m l = let aa0 = in_prod_sqr_obj m l in let aa = if o_isrot m <> 0 then aa0 +. in_prod_co_objrot m l else aa0 in if 0.0 = aa then 0 else ( let bb0 = 2.0 *. solver2nd_mul_b m l in let bb = if o_isrot m <> 0 then bb0 +. solver2nd_rot_b m l else bb0 in let cc0 = in_prod_sqr_obj m solver_w_vec in let cc1 = if o_isrot m <> 0 then (cc0 +. in_prod_co_objrot m solver_w_vec) else cc0 in let cc = if o_form m = 3 then cc1 -. 1.0 else cc1 in let d = let d2 = 4.0 *. aa *. cc in (fsqr bb) -. d2 in if 0.0 < d then ( let sd = sqrt d in let t1 = if o_isinvert m then sd else -.sd in (solver_dist.(0) <- ((t1 -. bb) /. 2.0 /. aa); 1)) else 0) in let rec solver index l p = let m = objects.(index) in solver_w_vec.(0) <- p.(0) -. o_param_x m; solver_w_vec.(1) <- p.(1) -. o_param_y m; solver_w_vec.(2) <- p.(2) -. o_param_z m; let m_shape = o_form m in if m_shape = 1 then solver_rect m l else if m_shape = 2 then solver_surface m l else solver_second m l in let rec is_rect_outside m = if (if abs_float isoutside_q.(0) < o_param_a m then if abs_float isoutside_q.(1) < o_param_b m then if abs_float isoutside_q.(2) < o_param_c m then true else false else false else false) then o_isinvert m else not (o_isinvert m) in let rec is_plane_outside m = let w = (o_param_a m *. isoutside_q.(0) +. o_param_b m *. isoutside_q.(1) +. o_param_c m *. isoutside_q.(2)) in let s = 0.0 > w in not (xor (o_isinvert m) s) in let rec is_second_outside m = let w = in_prod_sqr_obj m isoutside_q in let w2 = if o_form m = 3 then w -. 1.0 else w in let w3 = if o_isrot m <> 0 then w2 +. in_prod_co_objrot m isoutside_q else w2 in let s = 0.0 > w3 in not (xor (o_isinvert m) s) in let rec is_outside m = isoutside_q.(0) <- chkinside_p.(0) -. o_param_x m; isoutside_q.(1) <- chkinside_p.(1) -. o_param_y m; isoutside_q.(2) <- chkinside_p.(2) -. o_param_z m; let m_shape = o_form m in if m_shape = 1 then is_rect_outside m else if m_shape = 2 then is_plane_outside m else is_second_outside m in let rec check_all_inside ofs iand = let head = iand.(ofs) in if head = -1 then true else ( if (is_outside (objects.(head))) then false else check_all_inside (ofs + 1) iand) in let rec shadow_check_and_group iand_ofs and_group p = if and_group.(iand_ofs) = -1 then false else let obj = and_group.(iand_ofs) in let t0 = solver obj light p in let t0p = solver_dist.(0) in if (if t0 <> 0 then t0p < -0.2 else false) then let t = t0p +. 0.0 in chkinside_p.(0) <- light.(0) *. t +. p.(0); chkinside_p.(1) <- light.(1) *. t +. p.(1); chkinside_p.(2) <- light.(2) *. t +. p.(2); if (check_all_inside 0 and_group) then true else shadow_check_and_group (iand_ofs + 1) and_group p else if o_isinvert (objects.(obj)) then shadow_check_and_group (iand_ofs + 1) and_group p else false in let rec shadow_check_one_or_group ofs or_group p = let head = or_group.(ofs) in if head = -1 then false else ( let and_group = and_net.(head) in let shadow_p = shadow_check_and_group 0 and_group p in if shadow_p then true else shadow_check_one_or_group (ofs + 1) or_group p) in let rec shadow_check_one_or_matrix ofs or_matrix p = let head = or_matrix.(ofs) in let range_primitive = head.(0) in if range_primitive = -1 then false else ( if range_primitive = 99 then if (shadow_check_one_or_group 1 head p) then true else shadow_check_one_or_matrix (ofs + 1) or_matrix p else let t = solver range_primitive light p in if t <> 0 then if solver_dist.(0) < -0.1 then if shadow_check_one_or_group 1 head p then true else shadow_check_one_or_matrix (ofs + 1) or_matrix p else shadow_check_one_or_matrix (ofs + 1) or_matrix p else shadow_check_one_or_matrix (ofs + 1) or_matrix p) in let rec solve_each_element iand_ofs and_group = let iobj = and_group.(iand_ofs) in if iobj = -1 then () else ( let t0 = solver iobj vscan viewpoint in if t0 <> 0 then ( let t0p = solver_dist.(0) in if -0.1 < t0p then if t0p < tmin.(0) then ( let t = t0p +. 0.0 in chkinside_p.(0) <- vscan.(0) *. t +. viewpoint.(0); chkinside_p.(1) <- vscan.(1) *. t +. viewpoint.(1); chkinside_p.(2) <- vscan.(2) *. t +. viewpoint.(2); if check_all_inside 0 and_group then ( tmin.(0) <- t; crashed_point.(0) <- chkinside_p.(0); crashed_point.(1) <- chkinside_p.(1); crashed_point.(2) <- chkinside_p.(2); intsec_rectside.(0) <- t0; crashed_object.(0) <- iobj) else ()) else () else ()) else ( if o_isinvert (objects.(iobj)) then () else end_flag.(0) <- (true)); if (not (end_flag.(0))) then solve_each_element (iand_ofs + 1) and_group else ()) in let rec solve_one_or_network ofs or_group = let head = or_group.(ofs) in if head = -1 then () else ( let and_group = and_net.(head) in end_flag.(0) <- false; solve_each_element 0 and_group; solve_one_or_network (ofs + 1) or_group) in let rec trace_or_matrix ofs or_network = let head = or_network.(ofs) in let range_primitive = head.(0) in if range_primitive = -1 then () else ( if range_primitive = 99 then (solve_one_or_network 1 head) else ( let t = solver range_primitive vscan viewpoint in if t <> 0 then let tp = solver_dist.(0) in if tp < tmin.(0) then (solve_one_or_network 1 head) else () else ()); trace_or_matrix (ofs + 1) or_network) in let rec tracer viewpoint vscan = ( tmin.(0) <- (1000000000.0); trace_or_matrix 0 (or_net.(0)); let t = tmin.(0) in if -0.1 < t then if t < 100000000.0 then true else false else false) in let rec get_nvector_rect _ = let rectside = intsec_rectside.(0) in if rectside = 1 then ( nvector.(0) <- -.(sgn (vscan.(0))); nvector.(1) <- 0.0; nvector.(2) <- 0.0) else if rectside = 2 then ( nvector.(0) <- 0.0; nvector.(1) <- -.(sgn (vscan.(1))); nvector.(2) <- 0.0) else if rectside = 3 then ( nvector.(0) <- 0.0; nvector.(1) <- 0.0; nvector.(2) <- -.(sgn (vscan.(2)))) else () in let rec get_nvector_plane m = nvector.(0) <- -.(o_param_a m); nvector.(1) <- -.(o_param_b m); nvector.(2) <- -.(o_param_c m) in ()
let rec raytracing nref energy = let crashed_p = tracer viewpoint vscan in if (not crashed_p) then if nref <> 0 then ( let hl = -.(in_prod vscan light) in if 0.0 < hl then ( let ihl = fsqr hl *. hl *. energy *. beam.(0) in rgb.(0) <- rgb.(0) +. ihl; rgb.(1) <- rgb.(1) +. ihl; rgb.(2) <- rgb.(2) +. ihl) else ()) else () else (); if crashed_p then ( let cobj = objects.(crashed_object.(0)) in get_nvector cobj crashed_point; let bright = if (shadow_check_one_or_matrix 0 or_net.(0) crashed_point) then 0.0 else ( let br = -.(in_prod nvector light) in let br1 = if 0.0 > br then 0.2 else br +. 0.2 in br1 *. energy *. o_diffuse cobj) in utexture cobj crashed_point; accumulate_vec_mul rgb texture_color bright; if nref > 4 then () else if 0.1 < energy then ( let w = (-2.0) *. in_prod vscan nvector in accumulate_vec_mul vscan nvector w; let m_surface = o_reflectiontype cobj in if m_surface = 1 then ( if 0.0 = (o_hilight cobj) then () else let hl = -.(in_prod vscan light) in if 0.0 < hl then ( let ihl = fsqr (fsqr hl) *. energy *. bright *. o_hilight cobj in rgb.(0) <- rgb.(0) +. ihl; rgb.(1) <- rgb.(1) +. ihl; rgb.(2) <- rgb.(2) +. ihl) else ()) else if m_surface = 2 then ( viewpoint.(0) <- crashed_point.(0); viewpoint.(1) <- crashed_point.(1); viewpoint.(2) <- crashed_point.(2); let energy2 = energy *. (1.0 -. o_diffuse cobj) in raytracing (nref + 1) energy2) else ()) else ()) else () in let rec write_rgb _ = ( let red = int_of_float rgb.(0) in let red = if red > 255 then 255 else red in print_byte red; let green = int_of_float rgb.(1) in let green = if green > 255 then 255 else green in print_byte green; let blue = int_of_float rgb.(2) in let blue = if blue > 255 then 255 else blue in print_byte blue) in let rec write_ppm_header _ = ( print_byte 80; print_byte (48 + 6); print_byte 10; print_int size.(0); print_byte 32; print_int size.(1); print_byte 10; print_int 255; print_byte 10) in let rec scan_point scanx = if scanx >= size.(0) then () else ( let sscanx = (float_of_int scanx -. scan_offset.(0)) *. scan_d.(0) in vscan.(0) <- (sscanx *. cos_v.(1) +. wscan.(0)); vscan.(1) <- (scan_sscany.(0) *. cos_v.(0) -. vp.(1)); vscan.(2) <- (-.sscanx *. sin_v.(1) +. wscan.(2)); let metric = sqrt ((fsqr sscanx) +. scan_met1.(0)) in vscan.(0) <- vscan.(0) /. metric; vscan.(1) <- vscan.(1) /. metric; vscan.(2) <- vscan.(2) /. metric; viewpoint.(0) <- view.(0); viewpoint.(1) <- view.(1); viewpoint.(2) <- view.(2); rgb.(0) <- 0.0; rgb.(1) <- 0.0; rgb.(2) <- 0.0; raytracing 0 1.0; write_rgb (); scan_point (scanx + 1)) in let rec scan_line scany = if scany < size.(0) then ( scan_sscany.(0) <- ( let t = (scan_offset.(0) -. 1.0 -. float_of_int scany) in scan_d.(0) *. t); scan_met1.(0) <- fsqr scan_sscany.(0) +. 40000.0; let t1 = scan_sscany.(0) *. sin_v.(0) in wscan.(0) <- t1 *. sin_v.(1) -. vp.(0); wscan.(2) <- t1 *. cos_v.(1) -. vp.(2); scan_point 0; scan_line (scany + 1)) else () in let rec scan_start _ = ( write_ppm_header (); let sizex = float_of_int size.(0) in scan_d.(0) <- 128.0 /. sizex; scan_offset.(0) <- sizex /. 2.0; scan_line 0) in let rec rt size_x size_y debug_p = ( size.(0) <- size_x; size.(1) <- size_y; dbg.(0) <- debug_p; read_parameter (); scan_start ()) in rt 768 768 false
let rec get_nvector_second_norot m p = nvector.(0) <- (p.(0) -. o_param_x m) *. o_param_a m; nvector.(1) <- (p.(1) -. o_param_y m) *. o_param_b m; nvector.(2) <- (p.(2) -. o_param_z m) *. o_param_c m; normalize_vector nvector (o_isinvert m) in let rec get_nvector_second_rot m p = nvector_w.(0) <- p.(0) -. o_param_x m; nvector_w.(1) <- p.(1) -. o_param_y m; nvector_w.(2) <- p.(2) -. o_param_z m; nvector.(0) <- (nvector_w.(0)        *. o_param_a m +. fhalf (nvector_w.(1) *. o_param_r3 m +. nvector_w.(2) *. o_param_r2 m)); nvector.(1) <- (nvector_w.(1)        *. o_param_b m +. fhalf (nvector_w.(0) *. o_param_r3 m +. nvector_w.(2) *. o_param_r1 m)); nvector.(2) <- (nvector_w.(2)        *. o_param_c m +. fhalf (nvector_w.(0) *. o_param_r2 m +. nvector_w.(1) *. o_param_r1 m)); normalize_vector nvector (o_isinvert m) in let rec get_nvector m p = let m_shape = o_form m in if m_shape = 1 then get_nvector_rect () else if m_shape = 2 then get_nvector_plane m else if o_isrot m <> 0 then get_nvector_second_rot m p else get_nvector_second_norot m p in ()
let rec in_prod v1 v2 = v1.(0) *. v2.(0) +. v1.(1) *. v2.(1) +. v1.(2) *. v2.(2) in let rec accumulate_vec_mul v1 v2 w = v1.(0) <- v1.(0) +. w *. v2.(0); v1.(1) <- v1.(1) +. w *. v2.(1); v1.(2) <- v1.(2) +. w *. v2.(2) in ()
(let w1 = p.(0) -. o_param_x m in let flag1 = let d1 = (floor (w1 *. 0.0)) *. 20.0 in if w1 -. d1 < 10.0 then true else false in let w3 = p.(2) -. o_param_z m in let flag2 = let d2 = (floor (w3 *. 0.0)) *. 20.0 in if w3 -. d2 < 10.0 then true else false in texture_color.(1) <- if flag1 then (if flag2 then 255.0 else 0.0) else (if flag2 then 0.0 else 255.0))
let w2 = fsqr (sin (p.(1) *. 0.2)) in texture_color.(0) <- 255.0 *. w2; texture_color.(1) <- 255.0 *. (1.0 -. w2)
(let w1 = p.(0) -. o_param_x m in let w3 = p.(2) -. o_param_z m in let w2 = sqrt (fsqr w1 +. fsqr w3) /. 10.0 in let w4 =  (w2 -. floor w2) *. 3.1 in let cws = fsqr (cos w4) in texture_color.(1) <- cws *. 255.0; texture_color.(2) <- (1.0 -. cws) *. 255.0)
let rec utexture m p = let m_tex = o_texturetype m in texture_color.(0) <- o_color_red m; texture_color.(1) <- o_color_green m; texture_color.(2) <- o_color_blue m; if m_tex = 1 then () else if m_tex = 2 then () else if m_tex = 3 then () else if m_tex = 4 then () else () in ()
let w4 = sqrt ((fsqr w1) +. (fsqr w3)) in let w7 = if abs_float w1 < 1.0 then 15.0 else let w5 = abs_float (w3 /. w1) in (atan w5) *. (30.0 /. 3.1 ) in let w9 = w7 -. (floor w7) in let w2 = (p.(1) -. o_param_y m) *. (sqrt (o_param_b m)) in let w8 = if abs_float w7 < 1.0 then 15.0 else let w6 = abs_float (w2 /. w4) in (atan w6) *. (30.0 /. 3.1 ) in let w10 = w8 -. (floor w8) in let w11 = 0.1  -. (fsqr (0.5 -. w9)) -. (fsqr (0.5 -. w10)) in texture_color.(2) <- if 0.0 >= w11 then 0.0 else w11 *. (255.0 /. 0.3)
