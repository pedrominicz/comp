### Goal

Understand and write an abstract machine for executing functional programs. Should be close to a virtual machine for an imperative language (e.g. Lua). That is, instead of manipulating the abstract syntax tree, it should execute compiled bytecode.

### Resources
- [The ZINC Experiment: an economical implementation of the ML language](https://hal.inria.fr/inria-00070049/document)
- [Deriving the Full-Reducing Krivine Machine from the Small-Step Operational Semantics of Normal Order](https://oa.upm.es/30153/1/30153nogueiraINVES_MEM_2013.pdf)
- [On the Correctness and Efficiency of the Krivine Machine](http://www.ccs.neu.edu/home/wand/papers/wand-friedman-03.ps)
- [Improving the Lazy Krivine Machine](https://legacy.cs.indiana.edu/ftp/techreports/TR581.pdf)
- [Making a fast curry: push/enter vs. eval/apply for higher-order languages](https://www.cs.tufts.edu/comp/150FP/archive/simon-peyton-jones/eval-apply-jfp.pdf)
- [Compiling without Continuations](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/join-points-pldi17.pdf)
- [The Compiler Backend: Bytecode and Native code](https://dev.realworldocaml.org/compiler-backend.html)
- [Memory Representation of Values](https://dev.realworldocaml.org/runtime-memory-layout.html)
- [Haskell Benchmarking, Profiling, and Optimization](https://www.youtube.com/watch?v=vR_5F-kRIlY)
