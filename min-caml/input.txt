10
Int 10
10.
Float 10.0
10.2
Float 10.2
a.(2)
Get (Var "a") (Int 2)
-1
Neg (Int 1)
-1.
Float -1.0
1 + 1
Add (Int 1) (Int 1)
1 - 1
Sub (Int 1) (Int 1)
1 +. 1
FAdd (Int 1) (Int 1)
1 -. 1
FSub (Int 1) (Int 1)
1 *. 1
FMul (Int 1) (Int 1)
1 /. 1
FDiv (Int 1) (Int 1)
2 + 3 *. 4
Add (Int 2) (FMul (Int 3) (Int 4))
2 + 3 + 4
Add (Add (Int 2) (Int 3)) (Int 4)
(2 + 3) *. 4
FMul (Add (Int 2) (Int 3)) (Int 4)
a = b
Eq (Var "a") (Var "b")
a <> b
Not (Eq (Var "a") (Var "b"))
a <= b
LE (Var "a") (Var "b")
a >= b
LE (Var "b") (Var "a")
a < b
Not (LE (Var "b") (Var "a"))
a > b
Not (LE (Var "a") (Var "b"))
1 = 1 = true
Eq (Eq (Int 1) (Int 1)) (Bool True)
2. +. 2. = 2. *. 2.
Eq (FAdd (Float 2.0) (Float 2.0)) (FMul (Float 2.0) (Float 2.0))
-2.
Float -2.0
----0.
Float 0.0
----2
Neg (Neg (Neg (Neg (Int 2))))
2 + -2
Add (Int 2) (Neg (Int 2))
2 + -2.
Add (Int 2) (Float -2.0)
-2 + 2
Add (Neg (Int 2)) (Int 2)
-2. + 2
Add (Float -2.0) (Int 2)
hello world
App (Var "hello") ([Var "world"])
a -b
Sub (Var "a") (Var "b")
-a b
Neg (App (Var "a") ([Var "b"]))
f x y -z
Sub (App (Var "f") ([Var "x", Var "y"])) (Var "z")
-f x y -z
Sub (Neg (App (Var "f") ([Var "x", Var "y"]))) (Var "z")
1, 2, 3
Tuple [Int 1, Int 2, Int 3]
a, b, c
Tuple [Var "a", Var "b", Var "c"]
2. +. 2. = 2. *. 2., -2. + 2, -f x y -z
Tuple [Eq (FAdd (Float 2.0) (Float 2.0)) (FMul (Float 2.0) (Float 2.0)), Add (Float -2.0) (Int 2), Sub (Neg (App (Var "f") ([Var "x", Var "y"]))) (Var "z")]
a.(1) <- 1
Put (Var "a") (Int 1) (Int 1)
a.(1) <- 1 + 2
Put (Var "a") (Int 1) (Add (Int 1) (Int 2))
a.(1) <- 1 = 2
Put (Var "a") (Int 1) (Eq (Int 1) (Int 2))
a.(1) <- 1, 2
Put (Var "a") (Int 1) (Tuple [Int 1, Int 2])
a.(0).(1) <- 1
Put (Get (Var "a") (Int 0)) (Int 1) (Int 1)
a.(a.(0) <- 1) <- 1
Put (Var "a") (Put (Var "a") (Int 0) (Int 1)) (Int 1)
1;2;3
Let "" (Unit) (Int 1) (Let "" (Unit) (Int 2) (Int 3))
a.(1; 0) <- 1, 2
Put (Var "a") (Let "" (Unit) (Int 1) (Int 0)) (Tuple [Int 1, Int 2])
a.(a.(0) <- 1) <- 1; 2
Let "" (Unit) (Put (Var "a") (Put (Var "a") (Int 0) (Int 1)) (Int 1)) (Int 2)
const () 3.; 4
Let "" (Unit) (App (Var "const") ([Unit, Float 3.0])) (Int 4)
let x = 2 in x
Let "x" (Var 0) (Int 2) (Var "x")
let (a,b,c) = (1,2,3) in a
LetTuple [("a", Var 0), ("b", Var 0), ("c", Var 0)] (Tuple [Int 1, Int 2, Int 3]) (Var "a")
let rec const x y = x in const () 3.; 4
LetRec "const" (Var 0) [("x", Var 0), ("y", Var 0)] (Var "x") (Let "" (Unit) (App (Var "const") ([Unit, Float 3.0])) (Int 4))
let rec ack x y = if x <= 0 then y + 1 else if y <= 0 then ack (x - 1) 1 else ack (x - 1) (ack x (y - 1)) in print_int (ack 3 10)
LetRec "ack" (Var 0) [("x", Var 0), ("y", Var 0)] (If (LE (Var "x") (Int 0)) (Add (Var "y") (Int 1)) (If (LE (Var "y") (Int 0)) (App (Var "ack") ([Sub (Var "x") (Int 1), Int 1])) (App (Var "ack") ([Sub (Var "x") (Int 1), App (Var "ack") ([Var "x", Sub (Var "y") (Int 1)])])))) (App (Var "print_int") ([App (Var "ack") ([Int 3, Int 10])]))
let rec make_adder x = let rec adder y = x + y in adder in print_int ((make_adder 3) 7)
LetRec "make_adder" (Var 0) [("x", Var 0)] (LetRec "adder" (Var 0) [("y", Var 0)] (Add (Var "x") (Var "y")) (Var "adder")) (App (Var "print_int") ([App (App (Var "make_adder") ([Int 3])) ([Int 7])]))
let rec f x = x + 123 in let rec g y = f in print_int ((g 456) 789)
LetRec "f" (Var 0) [("x", Var 0)] (Add (Var "x") (Int 123)) (LetRec "g" (Var 0) [("y", Var 0)] (Var "f") (App (Var "print_int") ([App (App (Var "g") ([Int 456])) ([Int 789])])))
let rec f n = if n < 0 then () else (print_int n; let a = Array.make 1 f in a.(0) (n - 1)) in f 9
LetRec "f" (Var 0) [("n", Var 0)] (If (Not (LE (Int 0) (Var "n"))) (Unit) (Let "" (Unit) (App (Var "print_int") ([Var "n"])) (Let "a" (Var 0) (Array (Int 1) (Var "f")) (App (Get (Var "a") (Int 0)) ([Sub (Var "n") (Int 1)]))))) (App (Var "f") ([Int 9]))
let x = 10 in let rec f y = if y = 0 then 0 else x + f (y - 1) in print_int (f 123)
Let "x" (Var 0) (Int 10) (LetRec "f" (Var 0) [("y", Var 0)] (If (Eq (Var "y") (Int 0)) (Int 0) (Add (Var "x") (App (Var "f") ([Sub (Var "y") (Int 1)])))) (App (Var "print_int") ([App (Var "f") ([Int 123])])))
let rec h p = let (v1,v2,v3,v4,v5,v6,v7,v8,v9,v10) = p in let rec g z = let r = v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8 + v9 + v10 in if z > 0 then r else g (-z) in g 1 in print_int (h (1,2,3,4,5,6,7,8,9,10)); print_newline ()
LetRec "h" (Var 0) [("p", Var 0)] (LetTuple [("v1", Var 0), ("v2", Var 0), ("v3", Var 0), ("v4", Var 0), ("v5", Var 0), ("v6", Var 0), ("v7", Var 0), ("v8", Var 0), ("v9", Var 0), ("v10", Var 0)] (Var "p") (LetRec "g" (Var 0) [("z", Var 0)] (Let "r" (Var 0) (Add (Add (Add (Add (Add (Add (Add (Add (Add (Var "v1") (Var "v2")) (Var "v3")) (Var "v4")) (Var "v5")) (Var "v6")) (Var "v7")) (Var "v8")) (Var "v9")) (Var "v10")) (If (Not (LE (Var "z") (Int 0))) (Var "r") (App (Var "g") ([Neg (Var "z")])))) (App (Var "g") ([Int 1])))) (Let "" (Unit) (App (Var "print_int") ([App (Var "h") ([Tuple [Int 1, Int 2, Int 3, Int 4, Int 5, Int 6, Int 7, Int 8, Int 9, Int 10]])])) (App (Var "print_newline") ([Unit])))
let t = 123 in let f = 456 in let rec even x = let rec odd x = if x > 0 then even (x - 1) else if x < 0 then even (x + 1) else f in if x > 0 then odd (x - 1) else if x < 0 then odd (x + 1) else t in print_int (even 789)
Let "t" (Var 0) (Int 123) (Let "f" (Var 0) (Int 456) (LetRec "even" (Var 0) [("x", Var 0)] (LetRec "odd" (Var 0) [("x", Var 0)] (If (Not (LE (Var "x") (Int 0))) (App (Var "even") ([Sub (Var "x") (Int 1)])) (If (Not (LE (Int 0) (Var "x"))) (App (Var "even") ([Add (Var "x") (Int 1)])) (Var "f"))) (If (Not (LE (Var "x") (Int 0))) (App (Var "odd") ([Sub (Var "x") (Int 1)])) (If (Not (LE (Int 0) (Var "x"))) (App (Var "odd") ([Add (Var "x") (Int 1)])) (Var "t")))) (App (Var "print_int") ([App (Var "even") ([Int 789])]))))
let rec fib n = if n <= 1 then n else fib (n - 1) + fib (n - 2) in print_int (fib 30)
LetRec "fib" (Var 0) [("n", Var 0)] (If (LE (Var "n") (Int 1)) (Var "n") (Add (App (Var "fib") ([Sub (Var "n") (Int 1)])) (App (Var "fib") ([Sub (Var "n") (Int 2)])))) (App (Var "print_int") ([App (Var "fib") ([Int 30])]))
print_int (int_of_float ((sin (cos (sqrt (abs_float (-12.3)))) +. 4.5 -. 6.7 *. 8.9 /. 1.2) *. float_of_int 1000000))
App (Var "print_int") ([App (Var "int_of_float") ([FMul (FSub (FAdd (App (Var "sin") ([App (Var "cos") ([App (Var "sqrt") ([App (Var "abs_float") ([Float -12.3])])])])) (Float 4.5)) (FDiv (FMul (Float 6.7) (Float 8.9)) (Float 1.2))) (App (Var "float_of_int") ([Int 1000000]))])])
let rec compose f g = let rec composed x = g (f x) in composed in let rec dbl x = x + x in let rec inc x = x + 1 in let rec dec x = x - 1 in let h = compose inc (compose dbl dec) in print_int (h 123)
LetRec "compose" (Var 0) [("f", Var 0), ("g", Var 0)] (LetRec "composed" (Var 0) [("x", Var 0)] (App (Var "g") ([App (Var "f") ([Var "x"])])) (Var "composed")) (LetRec "dbl" (Var 0) [("x", Var 0)] (Add (Var "x") (Var "x")) (LetRec "inc" (Var 0) [("x", Var 0)] (Add (Var "x") (Int 1)) (LetRec "dec" (Var 0) [("x", Var 0)] (Sub (Var "x") (Int 1)) (Let "h" (Var 0) (App (Var "compose") ([Var "inc", App (Var "compose") ([Var "dbl", Var "dec"])])) (App (Var "print_int") ([App (Var "h") ([Int 123])]))))))
let rec gcd m n = if m = 0 then n else if m <= n then gcd m (n - m) else gcd n (m - n) in print_int (gcd 21600 337500)
LetRec "gcd" (Var 0) [("m", Var 0), ("n", Var 0)] (If (Eq (Var "m") (Int 0)) (Var "n") (If (LE (Var "m") (Var "n")) (App (Var "gcd") ([Var "m", Sub (Var "n") (Var "m")])) (App (Var "gcd") ([Var "n", Sub (Var "m") (Var "n")])))) (App (Var "print_int") ([App (Var "gcd") ([Int 21600, Int 337500])]))
let rec inprod v1 v2 acc i = if i < 0 then acc else inprod v1 v2 (acc +. v1.(i) *. v2.(i)) (i - 1) in let v1 = Array.make 3 1.2 in let v2 = Array.make 3 4.5 in print_int (truncate (1000000. *. inprod v1 v2 0. 2))
LetRec "inprod" (Var 0) [("v1", Var 0), ("v2", Var 0), ("acc", Var 0), ("i", Var 0)] (If (Not (LE (Int 0) (Var "i"))) (Var "acc") (App (Var "inprod") ([Var "v1", Var "v2", FAdd (Var "acc") (FMul (Get (Var "v1") (Var "i")) (Get (Var "v2") (Var "i"))), Sub (Var "i") (Int 1)]))) (Let "v1" (Var 0) (Array (Int 3) (Float 1.2)) (Let "v2" (Var 0) (Array (Int 3) (Float 4.5)) (App (Var "print_int") ([App (Var "truncate") ([FMul (Float 1000000.0) (App (Var "inprod") ([Var "v1", Var "v2", Float 0.0, Int 2]))])]))))
let rec inprod v1 v2 i = if i < 0 then 0.0 else v1.(i) *. v2.(i) +. inprod v1 v2 (i - 1) in let v1 = Array.make 3 1.2 in let v2 = Array.make 3 4.5 in print_int (truncate (1000000. *. inprod v1 v2 2))
LetRec "inprod" (Var 0) [("v1", Var 0), ("v2", Var 0), ("i", Var 0)] (If (Not (LE (Int 0) (Var "i"))) (Float 0.0) (FAdd (FMul (Get (Var "v1") (Var "i")) (Get (Var "v2") (Var "i"))) (App (Var "inprod") ([Var "v1", Var "v2", Sub (Var "i") (Int 1)])))) (Let "v1" (Var 0) (Array (Int 3) (Float 1.2)) (Let "v2" (Var 0) (Array (Int 3) (Float 4.5)) (App (Var "print_int") ([App (Var "truncate") ([FMul (Float 1000000.0) (App (Var "inprod") ([Var "v1", Var "v2", Int 2]))])]))))
let rec getx v = (let (x, y, z) = v in x) in let rec gety v = (let (x, y, z) = v in y) in let rec getz v = (let (x, y, z) = v in z) in let rec inprod v1 v2 = getx v1 *. getx v2 +. gety v1 *. gety v2 +. getz v1 *. getz v2 in print_int (truncate (1000000. *. inprod (1., 2., 3.) (4., 5., 6.)))
LetRec "getx" (Var 0) [("v", Var 0)] (LetTuple [("x", Var 0), ("y", Var 0), ("z", Var 0)] (Var "v") (Var "x")) (LetRec "gety" (Var 0) [("v", Var 0)] (LetTuple [("x", Var 0), ("y", Var 0), ("z", Var 0)] (Var "v") (Var "y")) (LetRec "getz" (Var 0) [("v", Var 0)] (LetTuple [("x", Var 0), ("y", Var 0), ("z", Var 0)] (Var "v") (Var "z")) (LetRec "inprod" (Var 0) [("v1", Var 0), ("v2", Var 0)] (FAdd (FAdd (FMul (App (Var "getx") ([Var "v1"])) (App (Var "getx") ([Var "v2"]))) (FMul (App (Var "gety") ([Var "v1"])) (App (Var "gety") ([Var "v2"])))) (FMul (App (Var "getz") ([Var "v1"])) (App (Var "getz") ([Var "v2"])))) (App (Var "print_int") ([App (Var "truncate") ([FMul (Float 1000000.0) (App (Var "inprod") ([Tuple [Float 1.0, Float 2.0, Float 3.0], Tuple [Float 4.0, Float 5.0, Float 6.0]]))])])))))
let rec f _ = 0 in 0
LetRec "f" (Var 0) [("", Var 0)] (Int 0) (Int 0)
let rec f _ = 123 in let rec g _ = 456 in let rec h _ = 789 in let x = f () in let y = g () in print_int ((if h () = 0 then x - y else y - x) + x + y)
LetRec "f" (Var 0) [("", Var 0)] (Int 123) (LetRec "g" (Var 0) [("", Var 0)] (Int 456) (LetRec "h" (Var 0) [("", Var 0)] (Int 789) (Let "x" (Var 0) (App (Var "f") ([Unit])) (Let "y" (Var 0) (App (Var "g") ([Unit])) (App (Var "print_int") ([Add (Add (If (Eq (App (Var "h") ([Unit])) (Int 0)) (Sub (Var "x") (Var "y")) (Sub (Var "y") (Var "x"))) (Var "x")) (Var "y")]))))))
let rec f _ = 123 in let rec g _ = 456 in let rec h _ = 789 in let x = f () in print_int ((if x <= 0 then g () + x else h () - x) + x)
LetRec "f" (Var 0) [("", Var 0)] (Int 123) (LetRec "g" (Var 0) [("", Var 0)] (Int 456) (LetRec "h" (Var 0) [("", Var 0)] (Int 789) (Let "x" (Var 0) (App (Var "f") ([Unit])) (App (Var "print_int") ([Add (If (LE (Var "x") (Int 0)) (Add (App (Var "g") ([Unit])) (Var "x")) (Sub (App (Var "h") ([Unit])) (Var "x"))) (Var "x")])))))
let rec f _ = 123 in let rec g _ = 456 in let rec h _ = 789 in let x = f () in let y = g () in print_int ((if h () = 0 then x + 1 else y + 2) + x + y)
LetRec "f" (Var 0) [("", Var 0)] (Int 123) (LetRec "g" (Var 0) [("", Var 0)] (Int 456) (LetRec "h" (Var 0) [("", Var 0)] (Int 789) (Let "x" (Var 0) (App (Var "f") ([Unit])) (Let "y" (Var 0) (App (Var "g") ([Unit])) (App (Var "print_int") ([Add (Add (If (Eq (App (Var "h") ([Unit])) (Int 0)) (Add (Var "x") (Int 1)) (Add (Var "y") (Int 2))) (Var "x")) (Var "y")]))))))
let rec f _ = 123 in let rec g _ = 456 in let x = f () in print_int ((if x <= 0 then g () + x else x) + x)
LetRec "f" (Var 0) [("", Var 0)] (Int 123) (LetRec "g" (Var 0) [("", Var 0)] (Int 456) (Let "x" (Var 0) (App (Var "f") ([Unit])) (App (Var "print_int") ([Add (If (LE (Var "x") (Int 0)) (Add (App (Var "g") ([Unit])) (Var "x")) (Var "x")) (Var "x")]))))
let rec f _ = 123 in let rec g _ = 456 in let rec h _ = 789 in let x = f () in print_int ((if x <= 0 then g () else h ()) + x)
LetRec "f" (Var 0) [("", Var 0)] (Int 123) (LetRec "g" (Var 0) [("", Var 0)] (Int 456) (LetRec "h" (Var 0) [("", Var 0)] (Int 789) (Let "x" (Var 0) (App (Var "f") ([Unit])) (App (Var "print_int") ([Add (If (LE (Var "x") (Int 0)) (App (Var "g") ([Unit])) (App (Var "h") ([Unit]))) (Var "x")])))))
let rec loop3 i k j a b c = if k < 0 then () else (c.(i).(j) <- c.(i).(j) +. a.(i).(k) *. b.(k).(j); loop3 i (k - 1) j a b c) in let rec loop2 i m j a b c = if j < 0 then () else (loop3 i (m - 1) j a b c; loop2 i m (j - 1) a b c) in let rec loop1 i m n a b c = if i < 0 then () else (loop2 i m (n - 1) a b c; loop1 (i - 1) m n a b c) in let rec mul l m n a b c = loop1 (l - 1) m n a b c in let dummy = Array.make 0 0. in let rec init i n mat = if i < 0 then () else (mat.(i) <- Array.make n 0.; init (i - 1) n mat) in let rec make m n dummy = let mat = Array.make m dummy in init (m - 1) n mat; mat in let a = make 2 3 dummy in let b = make 3 2 dummy in let c = make 2 2 dummy in a.(0).(0) <- 1.; a.(0).(1) <- 2.; a.(0).(2) <- 3.; a.(1).(0) <- 4.; a.(1).(1) <- 5.; a.(1).(2) <- 6.; b.(0).(0) <- 7.; b.(0).(1) <- 8.; b.(1).(0) <- 9.; b.(1).(1) <- 10.; b.(2).(0) <- 11.; b.(2).(1) <- 12.; mul 2 3 2 a b c; print_int (truncate (c.(0).(0))); print_newline (); print_int (truncate (c.(0).(1))); print_newline (); print_int (truncate (c.(1).(0))); print_newline (); print_int (truncate (c.(1).(1))); print_newline ()
LetRec "loop3" (Var 0) [("i", Var 0), ("k", Var 0), ("j", Var 0), ("a", Var 0), ("b", Var 0), ("c", Var 0)] (If (Not (LE (Int 0) (Var "k"))) (Unit) (Let "" (Unit) (Put (Get (Var "c") (Var "i")) (Var "j") (FAdd (Get (Get (Var "c") (Var "i")) (Var "j")) (FMul (Get (Get (Var "a") (Var "i")) (Var "k")) (Get (Get (Var "b") (Var "k")) (Var "j"))))) (App (Var "loop3") ([Var "i", Sub (Var "k") (Int 1), Var "j", Var "a", Var "b", Var "c"])))) (LetRec "loop2" (Var 0) [("i", Var 0), ("m", Var 0), ("j", Var 0), ("a", Var 0), ("b", Var 0), ("c", Var 0)] (If (Not (LE (Int 0) (Var "j"))) (Unit) (Let "" (Unit) (App (Var "loop3") ([Var "i", Sub (Var "m") (Int 1), Var "j", Var "a", Var "b", Var "c"])) (App (Var "loop2") ([Var "i", Var "m", Sub (Var "j") (Int 1), Var "a", Var "b", Var "c"])))) (LetRec "loop1" (Var 0) [("i", Var 0), ("m", Var 0), ("n", Var 0), ("a", Var 0), ("b", Var 0), ("c", Var 0)] (If (Not (LE (Int 0) (Var "i"))) (Unit) (Let "" (Unit) (App (Var "loop2") ([Var "i", Var "m", Sub (Var "n") (Int 1), Var "a", Var "b", Var "c"])) (App (Var "loop1") ([Sub (Var "i") (Int 1), Var "m", Var "n", Var "a", Var "b", Var "c"])))) (LetRec "mul" (Var 0) [("l", Var 0), ("m", Var 0), ("n", Var 0), ("a", Var 0), ("b", Var 0), ("c", Var 0)] (App (Var "loop1") ([Sub (Var "l") (Int 1), Var "m", Var "n", Var "a", Var "b", Var "c"])) (Let "dummy" (Var 0) (Array (Int 0) (Float 0.0)) (LetRec "init" (Var 0) [("i", Var 0), ("n", Var 0), ("mat", Var 0)] (If (Not (LE (Int 0) (Var "i"))) (Unit) (Let "" (Unit) (Put (Var "mat") (Var "i") (Array (Var "n") (Float 0.0))) (App (Var "init") ([Sub (Var "i") (Int 1), Var "n", Var "mat"])))) (LetRec "make" (Var 0) [("m", Var 0), ("n", Var 0), ("dummy", Var 0)] (Let "mat" (Var 0) (Array (Var "m") (Var "dummy")) (Let "" (Unit) (App (Var "init") ([Sub (Var "m") (Int 1), Var "n", Var "mat"])) (Var "mat"))) (Let "a" (Var 0) (App (Var "make") ([Int 2, Int 3, Var "dummy"])) (Let "b" (Var 0) (App (Var "make") ([Int 3, Int 2, Var "dummy"])) (Let "c" (Var 0) (App (Var "make") ([Int 2, Int 2, Var "dummy"])) (Let "" (Unit) (Put (Get (Var "a") (Int 0)) (Int 0) (Float 1.0)) (Let "" (Unit) (Put (Get (Var "a") (Int 0)) (Int 1) (Float 2.0)) (Let "" (Unit) (Put (Get (Var "a") (Int 0)) (Int 2) (Float 3.0)) (Let "" (Unit) (Put (Get (Var "a") (Int 1)) (Int 0) (Float 4.0)) (Let "" (Unit) (Put (Get (Var "a") (Int 1)) (Int 1) (Float 5.0)) (Let "" (Unit) (Put (Get (Var "a") (Int 1)) (Int 2) (Float 6.0)) (Let "" (Unit) (Put (Get (Var "b") (Int 0)) (Int 0) (Float 7.0)) (Let "" (Unit) (Put (Get (Var "b") (Int 0)) (Int 1) (Float 8.0)) (Let "" (Unit) (Put (Get (Var "b") (Int 1)) (Int 0) (Float 9.0)) (Let "" (Unit) (Put (Get (Var "b") (Int 1)) (Int 1) (Float 10.0)) (Let "" (Unit) (Put (Get (Var "b") (Int 2)) (Int 0) (Float 11.0)) (Let "" (Unit) (Put (Get (Var "b") (Int 2)) (Int 1) (Float 12.0)) (Let "" (Unit) (App (Var "mul") ([Int 2, Int 3, Int 2, Var "a", Var "b", Var "c"])) (Let "" (Unit) (App (Var "print_int") ([App (Var "truncate") ([Get (Get (Var "c") (Int 0)) (Int 0)])])) (Let "" (Unit) (App (Var "print_newline") ([Unit])) (Let "" (Unit) (App (Var "print_int") ([App (Var "truncate") ([Get (Get (Var "c") (Int 0)) (Int 1)])])) (Let "" (Unit) (App (Var "print_newline") ([Unit])) (Let "" (Unit) (App (Var "print_int") ([App (Var "truncate") ([Get (Get (Var "c") (Int 1)) (Int 0)])])) (Let "" (Unit) (App (Var "print_newline") ([Unit])) (Let "" (Unit) (App (Var "print_int") ([App (Var "truncate") ([Get (Get (Var "c") (Int 1)) (Int 1)])])) (App (Var "print_newline") ([Unit])))))))))))))))))))))))))))))))
if () then () else let x = () in ()
If (Unit) (Unit) (Let "x" (Var 0) (Unit) (Unit))
let rec mul l m n a b c = let rec loop1 i = if i < 0 then () else let rec loop2 j = if j < 0 then () else let rec loop3 k = if k < 0 then () else (c.(i).(j) <- c.(i).(j) +. a.(i).(k) *. b.(k).(j); loop3 (k - 1)) in loop3 (m - 1); loop2 (j - 1) in loop2 (n - 1); loop1 (i - 1) in loop1 (l - 1) in let dummy = Array.make 0 0. in let rec make m n = let mat = Array.make m dummy in let rec init i = if i < 0 then () else (mat.(i) <- Array.make n 0.; init (i - 1)) in init (m - 1); mat in let a = make 2 3 in let b = make 3 2 in let c = make 2 2 in a.(0).(0) <- 1.; a.(0).(1) <- 2.; a.(0).(2) <- 3.; a.(1).(0) <- 4.; a.(1).(1) <- 5.; a.(1).(2) <- 6.; b.(0).(0) <- 7.; b.(0).(1) <- 8.; b.(1).(0) <- 9.; b.(1).(1) <- 10.; b.(2).(0) <- 11.; b.(2).(1) <- 12.; mul 2 3 2 a b c; print_int (truncate (c.(0).(0))); print_newline (); print_int (truncate (c.(0).(1))); print_newline (); print_int (truncate (c.(1).(0))); print_newline (); print_int (truncate (c.(1).(1))); print_newline ()
LetRec "mul" (Var 0) [("l", Var 0), ("m", Var 0), ("n", Var 0), ("a", Var 0), ("b", Var 0), ("c", Var 0)] (LetRec "loop1" (Var 0) [("i", Var 0)] (If (Not (LE (Int 0) (Var "i"))) (Unit) (LetRec "loop2" (Var 0) [("j", Var 0)] (If (Not (LE (Int 0) (Var "j"))) (Unit) (LetRec "loop3" (Var 0) [("k", Var 0)] (If (Not (LE (Int 0) (Var "k"))) (Unit) (Let "" (Unit) (Put (Get (Var "c") (Var "i")) (Var "j") (FAdd (Get (Get (Var "c") (Var "i")) (Var "j")) (FMul (Get (Get (Var "a") (Var "i")) (Var "k")) (Get (Get (Var "b") (Var "k")) (Var "j"))))) (App (Var "loop3") ([Sub (Var "k") (Int 1)])))) (Let "" (Unit) (App (Var "loop3") ([Sub (Var "m") (Int 1)])) (App (Var "loop2") ([Sub (Var "j") (Int 1)]))))) (Let "" (Unit) (App (Var "loop2") ([Sub (Var "n") (Int 1)])) (App (Var "loop1") ([Sub (Var "i") (Int 1)]))))) (App (Var "loop1") ([Sub (Var "l") (Int 1)]))) (Let "dummy" (Var 0) (Array (Int 0) (Float 0.0)) (LetRec "make" (Var 0) [("m", Var 0), ("n", Var 0)] (Let "mat" (Var 0) (Array (Var "m") (Var "dummy")) (LetRec "init" (Var 0) [("i", Var 0)] (If (Not (LE (Int 0) (Var "i"))) (Unit) (Let "" (Unit) (Put (Var "mat") (Var "i") (Array (Var "n") (Float 0.0))) (App (Var "init") ([Sub (Var "i") (Int 1)])))) (Let "" (Unit) (App (Var "init") ([Sub (Var "m") (Int 1)])) (Var "mat")))) (Let "a" (Var 0) (App (Var "make") ([Int 2, Int 3])) (Let "b" (Var 0) (App (Var "make") ([Int 3, Int 2])) (Let "c" (Var 0) (App (Var "make") ([Int 2, Int 2])) (Let "" (Unit) (Put (Get (Var "a") (Int 0)) (Int 0) (Float 1.0)) (Let "" (Unit) (Put (Get (Var "a") (Int 0)) (Int 1) (Float 2.0)) (Let "" (Unit) (Put (Get (Var "a") (Int 0)) (Int 2) (Float 3.0)) (Let "" (Unit) (Put (Get (Var "a") (Int 1)) (Int 0) (Float 4.0)) (Let "" (Unit) (Put (Get (Var "a") (Int 1)) (Int 1) (Float 5.0)) (Let "" (Unit) (Put (Get (Var "a") (Int 1)) (Int 2) (Float 6.0)) (Let "" (Unit) (Put (Get (Var "b") (Int 0)) (Int 0) (Float 7.0)) (Let "" (Unit) (Put (Get (Var "b") (Int 0)) (Int 1) (Float 8.0)) (Let "" (Unit) (Put (Get (Var "b") (Int 1)) (Int 0) (Float 9.0)) (Let "" (Unit) (Put (Get (Var "b") (Int 1)) (Int 1) (Float 10.0)) (Let "" (Unit) (Put (Get (Var "b") (Int 2)) (Int 0) (Float 11.0)) (Let "" (Unit) (Put (Get (Var "b") (Int 2)) (Int 1) (Float 12.0)) (Let "" (Unit) (App (Var "mul") ([Int 2, Int 3, Int 2, Var "a", Var "b", Var "c"])) (Let "" (Unit) (App (Var "print_int") ([App (Var "truncate") ([Get (Get (Var "c") (Int 0)) (Int 0)])])) (Let "" (Unit) (App (Var "print_newline") ([Unit])) (Let "" (Unit) (App (Var "print_int") ([App (Var "truncate") ([Get (Get (Var "c") (Int 0)) (Int 1)])])) (Let "" (Unit) (App (Var "print_newline") ([Unit])) (Let "" (Unit) (App (Var "print_int") ([App (Var "truncate") ([Get (Get (Var "c") (Int 1)) (Int 0)])])) (Let "" (Unit) (App (Var "print_newline") ([Unit])) (Let "" (Unit) (App (Var "print_int") ([App (Var "truncate") ([Get (Get (Var "c") (Int 1)) (Int 1)])])) (App (Var "print_newline") ([Unit])))))))))))))))))))))))))))
print_int (if z < 0 then y else x)
App (Var "print_int") ([If (Not (LE (Int 0) (Var "z"))) (Var "y") (Var "x")])
print_int ((if z < 0 then y else x) + (if x > 0 then z else y) + (if y < 0 then x else z))
App (Var "print_int") ([Add (Add (If (Not (LE (Int 0) (Var "z"))) (Var "y") (Var "x")) (If (Not (LE (Var "x") (Int 0))) (Var "z") (Var "y"))) (If (Not (LE (Int 0) (Var "y"))) (Var "x") (Var "z"))])
let z = truncate (-.7.8) in print_int ((if z < 0 then y else x) + (if x > 0 then z else y) + (if y < 0 then x else z))
Let "z" (Var 0) (App (Var "truncate") ([FNeg (Float 7.8)])) (App (Var "print_int") ([Add (Add (If (Not (LE (Int 0) (Var "z"))) (Var "y") (Var "x")) (If (Not (LE (Var "x") (Int 0))) (Var "z") (Var "y"))) (If (Not (LE (Int 0) (Var "y"))) (Var "x") (Var "z"))]))
let x = truncate 1.2 in let y = truncate 4.5 in let z = truncate (-.7.8) in print_int ((if z < 0 then y else x) + (if x > 0 then z else y) + (if y < 0 then x else z))
Let "x" (Var 0) (App (Var "truncate") ([Float 1.2])) (Let "y" (Var 0) (App (Var "truncate") ([Float 4.5])) (Let "z" (Var 0) (App (Var "truncate") ([FNeg (Float 7.8)])) (App (Var "print_int") ([Add (Add (If (Not (LE (Int 0) (Var "z"))) (Var "y") (Var "x")) (If (Not (LE (Var "x") (Int 0))) (Var "z") (Var "y"))) (If (Not (LE (Int 0) (Var "y"))) (Var "x") (Var "z"))]))))
let rec f _ = 12345 in let y = Array.make 10 3 in let x = 67890 in print_int (if y.(0) = 3 then f () + y.(1) + x else 7)
LetRec "f" (Var 0) [("", Var 0)] (Int 12345) (Let "y" (Var 0) (Array (Int 10) (Int 3)) (Let "x" (Var 0) (Int 67890) (App (Var "print_int") ([If (Eq (Get (Var "y") (Int 0)) (Int 3)) (Add (Add (App (Var "f") ([Unit])) (Get (Var "y") (Int 1))) (Var "x")) (Int 7)]))))
print_int 123; print_int (-456); print_int (789+0)
Let "" (Unit) (App (Var "print_int") ([Int 123])) (Let "" (Unit) (App (Var "print_int") ([Neg (Int 456)])) (App (Var "print_int") ([Add (Int 789) (Int 0)])))
let rec foo a b c d e f = print_int a; print_int b; print_int c; print_int d; print_int e; print_int f in let rec bar a b c d e f = foo b a d e f c in bar 1 2 3 4 5 6
LetRec "foo" (Var 0) [("a", Var 0), ("b", Var 0), ("c", Var 0), ("d", Var 0), ("e", Var 0), ("f", Var 0)] (Let "" (Unit) (App (Var "print_int") ([Var "a"])) (Let "" (Unit) (App (Var "print_int") ([Var "b"])) (Let "" (Unit) (App (Var "print_int") ([Var "c"])) (Let "" (Unit) (App (Var "print_int") ([Var "d"])) (Let "" (Unit) (App (Var "print_int") ([Var "e"])) (App (Var "print_int") ([Var "f"]))))))) (LetRec "bar" (Var 0) [("a", Var 0), ("b", Var 0), ("c", Var 0), ("d", Var 0), ("e", Var 0), ("f", Var 0)] (App (Var "foo") ([Var "b", Var "a", Var "d", Var "e", Var "f", Var "c"])) (App (Var "bar") ([Int 1, Int 2, Int 3, Int 4, Int 5, Int 6])))
let rec f a b c d = let e = a + b in let f = a + c in let g = a + d in let h = b + c in let i = b + d in let j = c + d in let k = e + f in let l = e + g in let m = e + h in let n = e + i in let o = e + j in let p = f + g in let q = f + h in let r = f + i in let s = f + j in let t = g + h in let u = g + i in let v = g + j in let w = h + i in let x = h + j in let y = i + j in let aa = k + l in let ab = k + m in let ac = k + n in let ad = k + o in let ae = k + p in let af = k + q in let ag = k + r in let ah = k + s in let ai = k + t in let aj = k + u in let ak = k + v in let al = k + w in let am = k + x in let an = k + y in let z = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q + r + s + t + u + v + w + x + y + aa + ab + ac + ad + ae + af + ag + ah + ai + aj + ak + al + am + an in -z in print_int (f 1 2 3 4)
LetRec "f" (Var 0) [("a", Var 0), ("b", Var 0), ("c", Var 0), ("d", Var 0)] (Let "e" (Var 0) (Add (Var "a") (Var "b")) (Let "f" (Var 0) (Add (Var "a") (Var "c")) (Let "g" (Var 0) (Add (Var "a") (Var "d")) (Let "h" (Var 0) (Add (Var "b") (Var "c")) (Let "i" (Var 0) (Add (Var "b") (Var "d")) (Let "j" (Var 0) (Add (Var "c") (Var "d")) (Let "k" (Var 0) (Add (Var "e") (Var "f")) (Let "l" (Var 0) (Add (Var "e") (Var "g")) (Let "m" (Var 0) (Add (Var "e") (Var "h")) (Let "n" (Var 0) (Add (Var "e") (Var "i")) (Let "o" (Var 0) (Add (Var "e") (Var "j")) (Let "p" (Var 0) (Add (Var "f") (Var "g")) (Let "q" (Var 0) (Add (Var "f") (Var "h")) (Let "r" (Var 0) (Add (Var "f") (Var "i")) (Let "s" (Var 0) (Add (Var "f") (Var "j")) (Let "t" (Var 0) (Add (Var "g") (Var "h")) (Let "u" (Var 0) (Add (Var "g") (Var "i")) (Let "v" (Var 0) (Add (Var "g") (Var "j")) (Let "w" (Var 0) (Add (Var "h") (Var "i")) (Let "x" (Var 0) (Add (Var "h") (Var "j")) (Let "y" (Var 0) (Add (Var "i") (Var "j")) (Let "aa" (Var 0) (Add (Var "k") (Var "l")) (Let "ab" (Var 0) (Add (Var "k") (Var "m")) (Let "ac" (Var 0) (Add (Var "k") (Var "n")) (Let "ad" (Var 0) (Add (Var "k") (Var "o")) (Let "ae" (Var 0) (Add (Var "k") (Var "p")) (Let "af" (Var 0) (Add (Var "k") (Var "q")) (Let "ag" (Var 0) (Add (Var "k") (Var "r")) (Let "ah" (Var 0) (Add (Var "k") (Var "s")) (Let "ai" (Var 0) (Add (Var "k") (Var "t")) (Let "aj" (Var 0) (Add (Var "k") (Var "u")) (Let "ak" (Var 0) (Add (Var "k") (Var "v")) (Let "al" (Var 0) (Add (Var "k") (Var "w")) (Let "am" (Var 0) (Add (Var "k") (Var "x")) (Let "an" (Var 0) (Add (Var "k") (Var "y")) (Let "z" (Var 0) (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Var "a") (Var "b")) (Var "c")) (Var "d")) (Var "e")) (Var "f")) (Var "g")) (Var "h")) (Var "i")) (Var "j")) (Var "k")) (Var "l")) (Var "m")) (Var "n")) (Var "o")) (Var "p")) (Var "q")) (Var "r")) (Var "s")) (Var "t")) (Var "u")) (Var "v")) (Var "w")) (Var "x")) (Var "y")) (Var "aa")) (Var "ab")) (Var "ac")) (Var "ad")) (Var "ae")) (Var "af")) (Var "ag")) (Var "ah")) (Var "ai")) (Var "aj")) (Var "ak")) (Var "al")) (Var "am")) (Var "an")) (Neg (Var "z")))))))))))))))))))))))))))))))))))))) (App (Var "print_int") ([App (Var "f") ([Int 1, Int 2, Int 3, Int 4])]))
let rec f _ = 12345 in let rec g y = y + 1 in let z = Array.make 10 1 in let x = f () in let y = 67890 in let z0 = z.(0) in let z1 = z0 + z0 in let z2 = z1 + z1 in let z3 = z2 + z2 in let z4 = z3 + z3 in let z5 = z4 + z4 in let z6 = z5 + z5 in let z7 = z6 + z6 in let z8 = z7 + z7 in let z9 = z8 + z8 in let z10 = z9 + z9 in let z11 = z10 + z10 in let z12 = z11 + z11 in let z13 = z12 + z12 in let z14 = z13 + z13 in let z15 = z14 + z14 in print_int (if z.(1) = 0 then g y else z0 + z1 + z2 + z3 + z4 + z5 + z6 + z7 + z8 + z9 + z10 + z11 + z12 + z13 + z14 + z15 + x)
LetRec "f" (Var 0) [("", Var 0)] (Int 12345) (LetRec "g" (Var 0) [("y", Var 0)] (Add (Var "y") (Int 1)) (Let "z" (Var 0) (Array (Int 10) (Int 1)) (Let "x" (Var 0) (App (Var "f") ([Unit])) (Let "y" (Var 0) (Int 67890) (Let "z0" (Var 0) (Get (Var "z") (Int 0)) (Let "z1" (Var 0) (Add (Var "z0") (Var "z0")) (Let "z2" (Var 0) (Add (Var "z1") (Var "z1")) (Let "z3" (Var 0) (Add (Var "z2") (Var "z2")) (Let "z4" (Var 0) (Add (Var "z3") (Var "z3")) (Let "z5" (Var 0) (Add (Var "z4") (Var "z4")) (Let "z6" (Var 0) (Add (Var "z5") (Var "z5")) (Let "z7" (Var 0) (Add (Var "z6") (Var "z6")) (Let "z8" (Var 0) (Add (Var "z7") (Var "z7")) (Let "z9" (Var 0) (Add (Var "z8") (Var "z8")) (Let "z10" (Var 0) (Add (Var "z9") (Var "z9")) (Let "z11" (Var 0) (Add (Var "z10") (Var "z10")) (Let "z12" (Var 0) (Add (Var "z11") (Var "z11")) (Let "z13" (Var 0) (Add (Var "z12") (Var "z12")) (Let "z14" (Var 0) (Add (Var "z13") (Var "z13")) (Let "z15" (Var 0) (Add (Var "z14") (Var "z14")) (App (Var "print_int") ([If (Eq (Get (Var "z") (Int 1)) (Int 0)) (App (Var "g") ([Var "y"])) (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Var "z0") (Var "z1")) (Var "z2")) (Var "z3")) (Var "z4")) (Var "z5")) (Var "z6")) (Var "z7")) (Var "z8")) (Var "z9")) (Var "z10")) (Var "z11")) (Var "z12")) (Var "z13")) (Var "z14")) (Var "z15")) (Var "x"))]))))))))))))))))))))))
let rec f x0 = let x1 = x0 + 1 in let x2 = x1 + 1 in let x3 = x2 + 1 in let x4 = x3 + 1 in let x5 = x4 + 1 in let x6 = x5 + 1 in let x7 = x6 + 1 in let x8 = x7 + 1 in let x9 = x8 + 1 in let x10 = x9 + 1 in let x11 = x10 + 1 in let x12 = x11 + 1 in let x13 = x12 + 1 in let x14 = x13 + 1 in let x15 = x14 + 1 in let x16 = x15 + 1 in let x17 = x16 + 1 in let x18 = x17 + 1 in let x19 = x18 + x1 in let x20 = x19 + x2 in let x21 = x20 + x3 in let x22 = x21 + x4 in let x23 = x22 + x5 in let x24 = x23 + x6 in let x25 = x24 + x7 in let x26 = x25 + x8 in let x27 = x26 + x9 in let x28 = x27 + x10 in let x29 = x28 + x11 in let x30 = x29 + x12 in let x31 = x30 + x13 in let x32 = x31 + x14 in let x33 = x32 + x15 in let x34 = x33 + x16 in let x35 = x34 + x17 in let x36 = x35 + x0 in x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x0 in print_int (f 0)
LetRec "f" (Var 0) [("x0", Var 0)] (Let "x1" (Var 0) (Add (Var "x0") (Int 1)) (Let "x2" (Var 0) (Add (Var "x1") (Int 1)) (Let "x3" (Var 0) (Add (Var "x2") (Int 1)) (Let "x4" (Var 0) (Add (Var "x3") (Int 1)) (Let "x5" (Var 0) (Add (Var "x4") (Int 1)) (Let "x6" (Var 0) (Add (Var "x5") (Int 1)) (Let "x7" (Var 0) (Add (Var "x6") (Int 1)) (Let "x8" (Var 0) (Add (Var "x7") (Int 1)) (Let "x9" (Var 0) (Add (Var "x8") (Int 1)) (Let "x10" (Var 0) (Add (Var "x9") (Int 1)) (Let "x11" (Var 0) (Add (Var "x10") (Int 1)) (Let "x12" (Var 0) (Add (Var "x11") (Int 1)) (Let "x13" (Var 0) (Add (Var "x12") (Int 1)) (Let "x14" (Var 0) (Add (Var "x13") (Int 1)) (Let "x15" (Var 0) (Add (Var "x14") (Int 1)) (Let "x16" (Var 0) (Add (Var "x15") (Int 1)) (Let "x17" (Var 0) (Add (Var "x16") (Int 1)) (Let "x18" (Var 0) (Add (Var "x17") (Int 1)) (Let "x19" (Var 0) (Add (Var "x18") (Var "x1")) (Let "x20" (Var 0) (Add (Var "x19") (Var "x2")) (Let "x21" (Var 0) (Add (Var "x20") (Var "x3")) (Let "x22" (Var 0) (Add (Var "x21") (Var "x4")) (Let "x23" (Var 0) (Add (Var "x22") (Var "x5")) (Let "x24" (Var 0) (Add (Var "x23") (Var "x6")) (Let "x25" (Var 0) (Add (Var "x24") (Var "x7")) (Let "x26" (Var 0) (Add (Var "x25") (Var "x8")) (Let "x27" (Var 0) (Add (Var "x26") (Var "x9")) (Let "x28" (Var 0) (Add (Var "x27") (Var "x10")) (Let "x29" (Var 0) (Add (Var "x28") (Var "x11")) (Let "x30" (Var 0) (Add (Var "x29") (Var "x12")) (Let "x31" (Var 0) (Add (Var "x30") (Var "x13")) (Let "x32" (Var 0) (Add (Var "x31") (Var "x14")) (Let "x33" (Var 0) (Add (Var "x32") (Var "x15")) (Let "x34" (Var 0) (Add (Var "x33") (Var "x16")) (Let "x35" (Var 0) (Add (Var "x34") (Var "x17")) (Let "x36" (Var 0) (Add (Var "x35") (Var "x0")) (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Var "x1") (Var "x2")) (Var "x3")) (Var "x4")) (Var "x5")) (Var "x6")) (Var "x7")) (Var "x8")) (Var "x9")) (Var "x10")) (Var "x11")) (Var "x12")) (Var "x13")) (Var "x14")) (Var "x15")) (Var "x16")) (Var "x17")) (Var "x18")) (Var "x19")) (Var "x20")) (Var "x21")) (Var "x22")) (Var "x23")) (Var "x24")) (Var "x25")) (Var "x26")) (Var "x27")) (Var "x28")) (Var "x29")) (Var "x30")) (Var "x31")) (Var "x32")) (Var "x33")) (Var "x34")) (Var "x35")) (Var "x36")) (Var "x0")))))))))))))))))))))))))))))))))))))) (App (Var "print_int") ([App (Var "f") ([Int 0])]))
let rec sum acc x = if x <= 0 then acc else sum (acc + x) (x - 1) in print_int (sum 0 10000)
LetRec "sum" (Var 0) [("acc", Var 0), ("x", Var 0)] (If (LE (Var "x") (Int 0)) (Var "acc") (App (Var "sum") ([Add (Var "acc") (Var "x"), Sub (Var "x") (Int 1)]))) (App (Var "print_int") ([App (Var "sum") ([Int 0, Int 10000])]))
let rec sum x = if x <= 0 then 0 else sum (x - 1) + x in print_int (sum 10000)
LetRec "sum" (Var 0) [("x", Var 0)] (If (LE (Var "x") (Int 0)) (Int 0) (Add (App (Var "sum") ([Sub (Var "x") (Int 1)])) (Var "x"))) (App (Var "print_int") ([App (Var "sum") ([Int 10000])]))
let x = 42 in let rec f y1 y2 y3 y4 y5 = print_int (x + y1 + y2 + y3 + y4 + y5) in f 1 2 3 4 5
Let "x" (Var 0) (Int 42) (LetRec "f" (Var 0) [("y1", Var 0), ("y2", Var 0), ("y3", Var 0), ("y4", Var 0), ("y5", Var 0)] (App (Var "print_int") ([Add (Add (Add (Add (Add (Var "x") (Var "y1")) (Var "y2")) (Var "y3")) (Var "y4")) (Var "y5")])) (App (Var "f") ([Int 1, Int 2, Int 3, Int 4, Int 5])))
let x = 42 in let rec f y1 y2 y3 y4 y5 y6 = print_int x in f 1 2 3 4 5 6
Let "x" (Var 0) (Int 42) (LetRec "f" (Var 0) [("y1", Var 0), ("y2", Var 0), ("y3", Var 0), ("y4", Var 0), ("y5", Var 0), ("y6", Var 0)] (App (Var "print_int") ([Var "x"])) (App (Var "f") ([Int 1, Int 2, Int 3, Int 4, Int 5, Int 6])))
let rec xor x y = if x then not y else y in let rec fsqr x = x *. x in let rec fhalf x = x /. 2. in let rec o_texturetype m = let (m_tex, xm_shape, xm_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_tex in let rec o_form m = let (xm_tex, m_shape, xm_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_shape in let rec o_reflectiontype m = let (xm_tex, xm_shape, m_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_surface in let rec o_isinvert m = let (m_tex, m_shape, m_surface, m_isrot, xm_abc, xm_xyz, m_invert, xm_surfparams, xm_color, xm_rot123) = m in m_invert in let rec o_isrot m = let (xm_tex, xm_shape, xm_surface, m_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_isrot in let rec o_param_a m = let (xm_tex, xm_shape, xm_surface, xm_isrot, m_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_abc.(0) in let rec o_param_b m = let (xm_tex, xm_shape, xm_surface, xm_isrot, m_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_abc.(1) in let rec o_param_c m = let (xm_tex, xm_shape, xm_surface, xm_isrot, m_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_abc.(2) in let rec o_param_x m = let (xm_tex, xm_shape, xm_surface, xm_isrot, xm_abc, m_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_xyz.(0) in let rec o_param_y m = let (xm_tex, xm_shape, xm_surface, xm_isrot, xm_abc, m_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_xyz.(1) in let rec o_param_z m = let (xm_tex, xm_shape, xm_surface, xm_isrot, xm_abc, m_xyz, xm_invert, xm_surfparams, xm_color, xm_rot123) = m in m_xyz.(2) in let rec o_diffuse m = let (xm_tex, xm_shape, xm_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, m_surfparams, xm_color, xm_rot123) = m in m_surfparams.(0) in let rec o_hilight m = let (xm_tex, xm_shape, xm_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, m_surfparams, xm_color, xm_rot123) = m in m_surfparams.(1) in let rec o_color_red m = let (xm_tex, xm_shape, m_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, m_color, xm_rot123) = m in m_color.(0) in let rec o_color_green m = let (xm_tex, xm_shape, m_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, m_color, xm_rot123) = m in m_color.(1) in let rec o_color_blue m = let (xm_tex, xm_shape, m_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, m_color, xm_rot123) = m in m_color.(2) in let rec o_param_r1 m = let (xm_tex, xm_shape, xm_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, m_rot123) = m in m_rot123.(0) in let rec o_param_r2 m = let (xm_tex, xm_shape, xm_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, m_rot123) = m in m_rot123.(1) in let rec o_param_r3 m = let (xm_tex, xm_shape, xm_surface, xm_isrot, xm_abc, xm_xyz, xm_invert, xm_surfparams, xm_color, m_rot123) = m in m_rot123.(2) in let rec normalize_vector v inv = let n0 = (sqrt (fsqr v.(0) +. fsqr v.(1) +. fsqr v.(2))) in let n = if inv then -.n0 else n0 in v.(0) <- v.(0) /. n; v.(1) <- v.(1) /. n; v.(2) <- v.(2) /. n in let rec sgn x = if 0.0 < x then 1.0 else -1.0 in let rec rad x = x *. (0.0) in let rec read_environ _ = screen.(0) <- read_float (); screen.(1) <- read_float (); screen.(2) <- read_float (); let v1 = rad (read_float ()) in cos_v.(0) <- cos v1; sin_v.(0) <- sin v1; let v2 = rad (read_float ()) in cos_v.(1) <- cos v2; sin_v.(1) <- sin v2; let nl = read_float () in let l1 = rad (read_float ()) in let sl1 = sin l1 in light.(1) <- -.sl1; let l2 = rad (read_float ()) in let cl1 = cos l1 in let sl2 = sin l2 in light.(0) <- cl1 *. sl2; let cl2 = cos l2 in light.(2) <- cl1 *. cl2; beam.(0) <- read_float (); vp.(0) <- cos_v.(0) *. sin_v.(1) *. (-200.0); vp.(1) <- (-.sin_v.(0)) *. (-200.0); vp.(2) <- cos_v.(0) *. cos_v.(1) *. (-200.0); view.(0) <- vp.(0) +. screen.(0); view.(1) <- vp.(1) +. screen.(1); view.(2) <- vp.(2) +. screen.(2) in let rec read_nth_object n = let texture = read_int () in if texture <> -1 then ( let form = read_int () in let refltype = read_int () in let isrot_p = read_int () in let abc = Array.make 3 0.0 in abc.(0) <- read_float (); abc.(1) <- read_float (); abc.(2) <- read_float (); let xyz = Array.make 3 0.0 in xyz.(0) <- read_float (); xyz.(1) <- read_float (); xyz.(2) <- read_float (); let m_invert = 0.0 > (read_float ()) in let reflparam = Array.make 2 0.0 in reflparam.(0) <- read_float (); reflparam.(1) <- read_float (); let color = Array.make 3 0.0 in color.(0) <- read_float (); color.(1) <- read_float (); color.(2) <- read_float (); let rotation = Array.make 3 0.0 in if isrot_p <> 0 then ( rotation.(0) <- rad (read_float ()); rotation.(1) <- rad (read_float ()); rotation.(2) <- rad (read_float ()) ) else (); let m_invert2 = if form = 2 then true else m_invert in let obj = (texture, form, refltype, isrot_p, abc, xyz, m_invert2, reflparam, color, rotation ) in objects.(n) <- obj; if form = 3 then ( let a = abc.(0) in abc.(0) <- if 0.0 = a then 0.0 else (sgn a) /. (fsqr a); let b = abc.(1) in abc.(1) <- if 0.0 = b then 0.0 else (sgn b) /. (fsqr b); let c = abc.(2) in abc.(2) <- if 0.0 = c then 0.0 else (sgn c) /. (fsqr c)) else if form = 2 then normalize_vector abc (not m_invert) else (); if isrot_p <> 0 then ( cs_temp.(10) <- cos rotation.(0); cs_temp.(11) <- sin rotation.(0); cs_temp.(12) <- cos rotation.(1); cs_temp.(13) <- sin rotation.(1); cs_temp.(14) <- cos rotation.(2); cs_temp.(15) <- sin rotation.(2); cs_temp.(0) <- cs_temp.(12) *. cs_temp.(14); cs_temp.(1) <- (cs_temp.(11) *. cs_temp.(13) *. cs_temp.(14)) -. (cs_temp.(10) *. cs_temp.(15)); cs_temp.(2) <-        (cs_temp.(10) *. cs_temp.(13) *. cs_temp.(14)) +. (cs_temp.(11) *. cs_temp.(15)); cs_temp.(3) <-        cs_temp.(12) *. cs_temp.(15); cs_temp.(4) <-        (cs_temp.(11) *. cs_temp.(13) *. cs_temp.(15)) +. (cs_temp.(10) *. cs_temp.(14)); cs_temp.(5) <-        (cs_temp.(10) *. cs_temp.(13) *. cs_temp.(15)) -. (cs_temp.(11) *. cs_temp.(14)); cs_temp.(6) <-        -.cs_temp.(13); cs_temp.(7) <-        cs_temp.(11) *. cs_temp.(12); cs_temp.(8) <-        cs_temp.(10) *. cs_temp.(12); let ao = abc.(0) in let bo = abc.(1) in let co = abc.(2) in abc.(0) <- ao *. fsqr cs_temp.(0) +. bo *. fsqr cs_temp.(3) +. co *. fsqr cs_temp.(6); abc.(1) <- ao *. fsqr cs_temp.(1) +. bo *. fsqr cs_temp.(4) +. co *. fsqr cs_temp.(7); abc.(2) <- ao *. fsqr cs_temp.(2) +. bo *. fsqr cs_temp.(5) +. co *. fsqr cs_temp.(8); rotation.(0) <- 2.0 *. (ao *. cs_temp.(1) *. cs_temp.(2) +. bo *. cs_temp.(4) *. cs_temp.(5) +. co *. cs_temp.(7) *. cs_temp.(8)); rotation.(1) <- 2.0 *. (ao *. cs_temp.(0) *. cs_temp.(2) +. bo *. cs_temp.(3) *. cs_temp.(5) +. co *. cs_temp.(6) *. cs_temp.(8)); rotation.(2) <- 2.0 *. (ao *. cs_temp.(0) *. cs_temp.(1) +. bo *. cs_temp.(3) *. cs_temp.(4) +. co *. cs_temp.(6) *. cs_temp.(7))) else (); true) else false in let rec read_object n = if n < 61 then if read_nth_object n then read_object (n + 1) else () else () in let rec read_all_object _ = read_object 0 in let rec read_net_item length = let item = read_int () in if item = -1 then Array.make (length + 1) (-1) else let v = read_net_item (length + 1) in (v.(length) <- item; v) in let rec read_or_network length = let net = read_net_item 0 in if net.(0) = -1 then Array.make (length + 1) net else let v = read_or_network (length + 1) in (v.(length) <- net; v) in let rec read_and_network n = let net = read_net_item 0 in if net.(0) = -1 then () else ( and_net.(n) <- net; read_and_network (n + 1)) in let rec read_parameter _ = ( read_environ (); read_all_object (); read_and_network 0; or_net.(0) <- read_or_network 0) in let rec solver_rect m l = let answera = if 0.0 = l.(0) then false else ( let d = if xor (o_isinvert m) (0.0 > l.(0)) then (o_param_a m) else -.(o_param_a m) in let d2 = (d -. solver_w_vec.(0)) /. l.(0) in if abs_float (d2 *. l.(1) +. solver_w_vec.(1)) < o_param_b m then if abs_float (d2 *. l.(2) +. solver_w_vec.(2)) < o_param_c m then (solver_dist.(0) <- d2; true) else false else false) in if answera then 1 else let answerb = if 0.0 = l.(1) then false else ( let d = if xor (o_isinvert m) (0.0 > l.(1)) then (o_param_b m) else -.(o_param_b m) in let d2 = (d -. solver_w_vec.(1)) /. l.(1) in if abs_float (d2 *. l.(2) +. solver_w_vec.(2)) < o_param_c m then if abs_float (d2 *. l.(0) +. solver_w_vec.(0)) < o_param_a m then (solver_dist.(0) <- d2; true) else false else false) in if answerb then 2 else let answerc = if 0.0 = l.(2) then false else ( let d = if xor (o_isinvert m) (0.0 > l.(2)) then (o_param_c m) else -.(o_param_c m) in let d2 = (d -. solver_w_vec.(2)) /. l.(2) in if abs_float (d2 *. l.(0) +. solver_w_vec.(0)) < o_param_a m then if abs_float (d2 *. l.(1) +. solver_w_vec.(1)) < o_param_b m then (solver_dist.(0) <- d2; true) else false else false) in if answerc then 3 else 0 in ()
LetRec "xor" (Var 0) [("x", Var 0), ("y", Var 0)] (If (Var "x") (Not (Var "y")) (Var "y")) (LetRec "fsqr" (Var 0) [("x", Var 0)] (FMul (Var "x") (Var "x")) (LetRec "fhalf" (Var 0) [("x", Var 0)] (FDiv (Var "x") (Float 2.0)) (LetRec "o_texturetype" (Var 0) [("m", Var 0)] (LetTuple [("m_tex", Var 0), ("xm_shape", Var 0), ("xm_surface", Var 0), ("xm_isrot", Var 0), ("xm_abc", Var 0), ("xm_xyz", Var 0), ("xm_invert", Var 0), ("xm_surfparams", Var 0), ("xm_color", Var 0), ("xm_rot123", Var 0)] (Var "m") (Var "m_tex")) (LetRec "o_form" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("m_shape", Var 0), ("xm_surface", Var 0), ("xm_isrot", Var 0), ("xm_abc", Var 0), ("xm_xyz", Var 0), ("xm_invert", Var 0), ("xm_surfparams", Var 0), ("xm_color", Var 0), ("xm_rot123", Var 0)] (Var "m") (Var "m_shape")) (LetRec "o_reflectiontype" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("xm_shape", Var 0), ("m_surface", Var 0), ("xm_isrot", Var 0), ("xm_abc", Var 0), ("xm_xyz", Var 0), ("xm_invert", Var 0), ("xm_surfparams", Var 0), ("xm_color", Var 0), ("xm_rot123", Var 0)] (Var "m") (Var "m_surface")) (LetRec "o_isinvert" (Var 0) [("m", Var 0)] (LetTuple [("m_tex", Var 0), ("m_shape", Var 0), ("m_surface", Var 0), ("m_isrot", Var 0), ("xm_abc", Var 0), ("xm_xyz", Var 0), ("m_invert", Var 0), ("xm_surfparams", Var 0), ("xm_color", Var 0), ("xm_rot123", Var 0)] (Var "m") (Var "m_invert")) (LetRec "o_isrot" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("xm_shape", Var 0), ("xm_surface", Var 0), ("m_isrot", Var 0), ("xm_abc", Var 0), ("xm_xyz", Var 0), ("xm_invert", Var 0), ("xm_surfparams", Var 0), ("xm_color", Var 0), ("xm_rot123", Var 0)] (Var "m") (Var "m_isrot")) (LetRec "o_param_a" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("xm_shape", Var 0), ("xm_surface", Var 0), ("xm_isrot", Var 0), ("m_abc", Var 0), ("xm_xyz", Var 0), ("xm_invert", Var 0), ("xm_surfparams", Var 0), ("xm_color", Var 0), ("xm_rot123", Var 0)] (Var "m") (Get (Var "m_abc") (Int 0))) (LetRec "o_param_b" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("xm_shape", Var 0), ("xm_surface", Var 0), ("xm_isrot", Var 0), ("m_abc", Var 0), ("xm_xyz", Var 0), ("xm_invert", Var 0), ("xm_surfparams", Var 0), ("xm_color", Var 0), ("xm_rot123", Var 0)] (Var "m") (Get (Var "m_abc") (Int 1))) (LetRec "o_param_c" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("xm_shape", Var 0), ("xm_surface", Var 0), ("xm_isrot", Var 0), ("m_abc", Var 0), ("xm_xyz", Var 0), ("xm_invert", Var 0), ("xm_surfparams", Var 0), ("xm_color", Var 0), ("xm_rot123", Var 0)] (Var "m") (Get (Var "m_abc") (Int 2))) (LetRec "o_param_x" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("xm_shape", Var 0), ("xm_surface", Var 0), ("xm_isrot", Var 0), ("xm_abc", Var 0), ("m_xyz", Var 0), ("xm_invert", Var 0), ("xm_surfparams", Var 0), ("xm_color", Var 0), ("xm_rot123", Var 0)] (Var "m") (Get (Var "m_xyz") (Int 0))) (LetRec "o_param_y" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("xm_shape", Var 0), ("xm_surface", Var 0), ("xm_isrot", Var 0), ("xm_abc", Var 0), ("m_xyz", Var 0), ("xm_invert", Var 0), ("xm_surfparams", Var 0), ("xm_color", Var 0), ("xm_rot123", Var 0)] (Var "m") (Get (Var "m_xyz") (Int 1))) (LetRec "o_param_z" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("xm_shape", Var 0), ("xm_surface", Var 0), ("xm_isrot", Var 0), ("xm_abc", Var 0), ("m_xyz", Var 0), ("xm_invert", Var 0), ("xm_surfparams", Var 0), ("xm_color", Var 0), ("xm_rot123", Var 0)] (Var "m") (Get (Var "m_xyz") (Int 2))) (LetRec "o_diffuse" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("xm_shape", Var 0), ("xm_surface", Var 0), ("xm_isrot", Var 0), ("xm_abc", Var 0), ("xm_xyz", Var 0), ("xm_invert", Var 0), ("m_surfparams", Var 0), ("xm_color", Var 0), ("xm_rot123", Var 0)] (Var "m") (Get (Var "m_surfparams") (Int 0))) (LetRec "o_hilight" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("xm_shape", Var 0), ("xm_surface", Var 0), ("xm_isrot", Var 0), ("xm_abc", Var 0), ("xm_xyz", Var 0), ("xm_invert", Var 0), ("m_surfparams", Var 0), ("xm_color", Var 0), ("xm_rot123", Var 0)] (Var "m") (Get (Var "m_surfparams") (Int 1))) (LetRec "o_color_red" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("xm_shape", Var 0), ("m_surface", Var 0), ("xm_isrot", Var 0), ("xm_abc", Var 0), ("xm_xyz", Var 0), ("xm_invert", Var 0), ("xm_surfparams", Var 0), ("m_color", Var 0), ("xm_rot123", Var 0)] (Var "m") (Get (Var "m_color") (Int 0))) (LetRec "o_color_green" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("xm_shape", Var 0), ("m_surface", Var 0), ("xm_isrot", Var 0), ("xm_abc", Var 0), ("xm_xyz", Var 0), ("xm_invert", Var 0), ("xm_surfparams", Var 0), ("m_color", Var 0), ("xm_rot123", Var 0)] (Var "m") (Get (Var "m_color") (Int 1))) (LetRec "o_color_blue" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("xm_shape", Var 0), ("m_surface", Var 0), ("xm_isrot", Var 0), ("xm_abc", Var 0), ("xm_xyz", Var 0), ("xm_invert", Var 0), ("xm_surfparams", Var 0), ("m_color", Var 0), ("xm_rot123", Var 0)] (Var "m") (Get (Var "m_color") (Int 2))) (LetRec "o_param_r1" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("xm_shape", Var 0), ("xm_surface", Var 0), ("xm_isrot", Var 0), ("xm_abc", Var 0), ("xm_xyz", Var 0), ("xm_invert", Var 0), ("xm_surfparams", Var 0), ("xm_color", Var 0), ("m_rot123", Var 0)] (Var "m") (Get (Var "m_rot123") (Int 0))) (LetRec "o_param_r2" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("xm_shape", Var 0), ("xm_surface", Var 0), ("xm_isrot", Var 0), ("xm_abc", Var 0), ("xm_xyz", Var 0), ("xm_invert", Var 0), ("xm_surfparams", Var 0), ("xm_color", Var 0), ("m_rot123", Var 0)] (Var "m") (Get (Var "m_rot123") (Int 1))) (LetRec "o_param_r3" (Var 0) [("m", Var 0)] (LetTuple [("xm_tex", Var 0), ("xm_shape", Var 0), ("xm_surface", Var 0), ("xm_isrot", Var 0), ("xm_abc", Var 0), ("xm_xyz", Var 0), ("xm_invert", Var 0), ("xm_surfparams", Var 0), ("xm_color", Var 0), ("m_rot123", Var 0)] (Var "m") (Get (Var "m_rot123") (Int 2))) (LetRec "normalize_vector" (Var 0) [("v", Var 0), ("inv", Var 0)] (Let "n0" (Var 0) (App (Var "sqrt") ([FAdd (FAdd (App (Var "fsqr") ([Get (Var "v") (Int 0)])) (App (Var "fsqr") ([Get (Var "v") (Int 1)]))) (App (Var "fsqr") ([Get (Var "v") (Int 2)]))])) (Let "n" (Var 0) (If (Var "inv") (FNeg (Var "n0")) (Var "n0")) (Let "" (Unit) (Put (Var "v") (Int 0) (FDiv (Get (Var "v") (Int 0)) (Var "n"))) (Let "" (Unit) (Put (Var "v") (Int 1) (FDiv (Get (Var "v") (Int 1)) (Var "n"))) (Put (Var "v") (Int 2) (FDiv (Get (Var "v") (Int 2)) (Var "n"))))))) (LetRec "sgn" (Var 0) [("x", Var 0)] (If (Not (LE (Var "x") (Float 0.0))) (Float 1.0) (Float -1.0)) (LetRec "rad" (Var 0) [("x", Var 0)] (FMul (Var "x") (Float 0.0)) (LetRec "read_environ" (Var 0) [("", Var 0)] (Let "" (Unit) (Put (Var "screen") (Int 0) (App (Var "read_float") ([Unit]))) (Let "" (Unit) (Put (Var "screen") (Int 1) (App (Var "read_float") ([Unit]))) (Let "" (Unit) (Put (Var "screen") (Int 2) (App (Var "read_float") ([Unit]))) (Let "v1" (Var 0) (App (Var "rad") ([App (Var "read_float") ([Unit])])) (Let "" (Unit) (Put (Var "cos_v") (Int 0) (App (Var "cos") ([Var "v1"]))) (Let "" (Unit) (Put (Var "sin_v") (Int 0) (App (Var "sin") ([Var "v1"]))) (Let "v2" (Var 0) (App (Var "rad") ([App (Var "read_float") ([Unit])])) (Let "" (Unit) (Put (Var "cos_v") (Int 1) (App (Var "cos") ([Var "v2"]))) (Let "" (Unit) (Put (Var "sin_v") (Int 1) (App (Var "sin") ([Var "v2"]))) (Let "nl" (Var 0) (App (Var "read_float") ([Unit])) (Let "l1" (Var 0) (App (Var "rad") ([App (Var "read_float") ([Unit])])) (Let "sl1" (Var 0) (App (Var "sin") ([Var "l1"])) (Let "" (Unit) (Put (Var "light") (Int 1) (FNeg (Var "sl1"))) (Let "l2" (Var 0) (App (Var "rad") ([App (Var "read_float") ([Unit])])) (Let "cl1" (Var 0) (App (Var "cos") ([Var "l1"])) (Let "sl2" (Var 0) (App (Var "sin") ([Var "l2"])) (Let "" (Unit) (Put (Var "light") (Int 0) (FMul (Var "cl1") (Var "sl2"))) (Let "cl2" (Var 0) (App (Var "cos") ([Var "l2"])) (Let "" (Unit) (Put (Var "light") (Int 2) (FMul (Var "cl1") (Var "cl2"))) (Let "" (Unit) (Put (Var "beam") (Int 0) (App (Var "read_float") ([Unit]))) (Let "" (Unit) (Put (Var "vp") (Int 0) (FMul (FMul (Get (Var "cos_v") (Int 0)) (Get (Var "sin_v") (Int 1))) (Float -200.0))) (Let "" (Unit) (Put (Var "vp") (Int 1) (FMul (FNeg (Get (Var "sin_v") (Int 0))) (Float -200.0))) (Let "" (Unit) (Put (Var "vp") (Int 2) (FMul (FMul (Get (Var "cos_v") (Int 0)) (Get (Var "cos_v") (Int 1))) (Float -200.0))) (Let "" (Unit) (Put (Var "view") (Int 0) (FAdd (Get (Var "vp") (Int 0)) (Get (Var "screen") (Int 0)))) (Let "" (Unit) (Put (Var "view") (Int 1) (FAdd (Get (Var "vp") (Int 1)) (Get (Var "screen") (Int 1)))) (Put (Var "view") (Int 2) (FAdd (Get (Var "vp") (Int 2)) (Get (Var "screen") (Int 2))))))))))))))))))))))))))))) (LetRec "read_nth_object" (Var 0) [("n", Var 0)] (Let "texture" (Var 0) (App (Var "read_int") ([Unit])) (If (Not (Eq (Var "texture") (Neg (Int 1)))) (Let "form" (Var 0) (App (Var "read_int") ([Unit])) (Let "refltype" (Var 0) (App (Var "read_int") ([Unit])) (Let "isrot_p" (Var 0) (App (Var "read_int") ([Unit])) (Let "abc" (Var 0) (Array (Int 3) (Float 0.0)) (Let "" (Unit) (Put (Var "abc") (Int 0) (App (Var "read_float") ([Unit]))) (Let "" (Unit) (Put (Var "abc") (Int 1) (App (Var "read_float") ([Unit]))) (Let "" (Unit) (Put (Var "abc") (Int 2) (App (Var "read_float") ([Unit]))) (Let "xyz" (Var 0) (Array (Int 3) (Float 0.0)) (Let "" (Unit) (Put (Var "xyz") (Int 0) (App (Var "read_float") ([Unit]))) (Let "" (Unit) (Put (Var "xyz") (Int 1) (App (Var "read_float") ([Unit]))) (Let "" (Unit) (Put (Var "xyz") (Int 2) (App (Var "read_float") ([Unit]))) (Let "m_invert" (Var 0) (Not (LE (Float 0.0) (App (Var "read_float") ([Unit])))) (Let "reflparam" (Var 0) (Array (Int 2) (Float 0.0)) (Let "" (Unit) (Put (Var "reflparam") (Int 0) (App (Var "read_float") ([Unit]))) (Let "" (Unit) (Put (Var "reflparam") (Int 1) (App (Var "read_float") ([Unit]))) (Let "color" (Var 0) (Array (Int 3) (Float 0.0)) (Let "" (Unit) (Put (Var "color") (Int 0) (App (Var "read_float") ([Unit]))) (Let "" (Unit) (Put (Var "color") (Int 1) (App (Var "read_float") ([Unit]))) (Let "" (Unit) (Put (Var "color") (Int 2) (App (Var "read_float") ([Unit]))) (Let "rotation" (Var 0) (Array (Int 3) (Float 0.0)) (Let "" (Unit) (If (Not (Eq (Var "isrot_p") (Int 0))) (Let "" (Unit) (Put (Var "rotation") (Int 0) (App (Var "rad") ([App (Var "read_float") ([Unit])]))) (Let "" (Unit) (Put (Var "rotation") (Int 1) (App (Var "rad") ([App (Var "read_float") ([Unit])]))) (Put (Var "rotation") (Int 2) (App (Var "rad") ([App (Var "read_float") ([Unit])]))))) (Unit)) (Let "m_invert2" (Var 0) (If (Eq (Var "form") (Int 2)) (Bool True) (Var "m_invert")) (Let "obj" (Var 0) (Tuple [Var "texture", Var "form", Var "refltype", Var "isrot_p", Var "abc", Var "xyz", Var "m_invert2", Var "reflparam", Var "color", Var "rotation"]) (Let "" (Unit) (Put (Var "objects") (Var "n") (Var "obj")) (Let "" (Unit) (If (Eq (Var "form") (Int 3)) (Let "a" (Var 0) (Get (Var "abc") (Int 0)) (Let "" (Unit) (Put (Var "abc") (Int 0) (If (Eq (Float 0.0) (Var "a")) (Float 0.0) (FDiv (App (Var "sgn") ([Var "a"])) (App (Var "fsqr") ([Var "a"]))))) (Let "b" (Var 0) (Get (Var "abc") (Int 1)) (Let "" (Unit) (Put (Var "abc") (Int 1) (If (Eq (Float 0.0) (Var "b")) (Float 0.0) (FDiv (App (Var "sgn") ([Var "b"])) (App (Var "fsqr") ([Var "b"]))))) (Let "c" (Var 0) (Get (Var "abc") (Int 2)) (Put (Var "abc") (Int 2) (If (Eq (Float 0.0) (Var "c")) (Float 0.0) (FDiv (App (Var "sgn") ([Var "c"])) (App (Var "fsqr") ([Var "c"])))))))))) (If (Eq (Var "form") (Int 2)) (App (Var "normalize_vector") ([Var "abc", Not (Var "m_invert")])) (Unit))) (Let "" (Unit) (If (Not (Eq (Var "isrot_p") (Int 0))) (Let "" (Unit) (Put (Var "cs_temp") (Int 10) (App (Var "cos") ([Get (Var "rotation") (Int 0)]))) (Let "" (Unit) (Put (Var "cs_temp") (Int 11) (App (Var "sin") ([Get (Var "rotation") (Int 0)]))) (Let "" (Unit) (Put (Var "cs_temp") (Int 12) (App (Var "cos") ([Get (Var "rotation") (Int 1)]))) (Let "" (Unit) (Put (Var "cs_temp") (Int 13) (App (Var "sin") ([Get (Var "rotation") (Int 1)]))) (Let "" (Unit) (Put (Var "cs_temp") (Int 14) (App (Var "cos") ([Get (Var "rotation") (Int 2)]))) (Let "" (Unit) (Put (Var "cs_temp") (Int 15) (App (Var "sin") ([Get (Var "rotation") (Int 2)]))) (Let "" (Unit) (Put (Var "cs_temp") (Int 0) (FMul (Get (Var "cs_temp") (Int 12)) (Get (Var "cs_temp") (Int 14)))) (Let "" (Unit) (Put (Var "cs_temp") (Int 1) (FSub (FMul (FMul (Get (Var "cs_temp") (Int 11)) (Get (Var "cs_temp") (Int 13))) (Get (Var "cs_temp") (Int 14))) (FMul (Get (Var "cs_temp") (Int 10)) (Get (Var "cs_temp") (Int 15))))) (Let "" (Unit) (Put (Var "cs_temp") (Int 2) (FAdd (FMul (FMul (Get (Var "cs_temp") (Int 10)) (Get (Var "cs_temp") (Int 13))) (Get (Var "cs_temp") (Int 14))) (FMul (Get (Var "cs_temp") (Int 11)) (Get (Var "cs_temp") (Int 15))))) (Let "" (Unit) (Put (Var "cs_temp") (Int 3) (FMul (Get (Var "cs_temp") (Int 12)) (Get (Var "cs_temp") (Int 15)))) (Let "" (Unit) (Put (Var "cs_temp") (Int 4) (FAdd (FMul (FMul (Get (Var "cs_temp") (Int 11)) (Get (Var "cs_temp") (Int 13))) (Get (Var "cs_temp") (Int 15))) (FMul (Get (Var "cs_temp") (Int 10)) (Get (Var "cs_temp") (Int 14))))) (Let "" (Unit) (Put (Var "cs_temp") (Int 5) (FSub (FMul (FMul (Get (Var "cs_temp") (Int 10)) (Get (Var "cs_temp") (Int 13))) (Get (Var "cs_temp") (Int 15))) (FMul (Get (Var "cs_temp") (Int 11)) (Get (Var "cs_temp") (Int 14))))) (Let "" (Unit) (Put (Var "cs_temp") (Int 6) (FNeg (Get (Var "cs_temp") (Int 13)))) (Let "" (Unit) (Put (Var "cs_temp") (Int 7) (FMul (Get (Var "cs_temp") (Int 11)) (Get (Var "cs_temp") (Int 12)))) (Let "" (Unit) (Put (Var "cs_temp") (Int 8) (FMul (Get (Var "cs_temp") (Int 10)) (Get (Var "cs_temp") (Int 12)))) (Let "ao" (Var 0) (Get (Var "abc") (Int 0)) (Let "bo" (Var 0) (Get (Var "abc") (Int 1)) (Let "co" (Var 0) (Get (Var "abc") (Int 2)) (Let "" (Unit) (Put (Var "abc") (Int 0) (FAdd (FAdd (FMul (Var "ao") (App (Var "fsqr") ([Get (Var "cs_temp") (Int 0)]))) (FMul (Var "bo") (App (Var "fsqr") ([Get (Var "cs_temp") (Int 3)])))) (FMul (Var "co") (App (Var "fsqr") ([Get (Var "cs_temp") (Int 6)]))))) (Let "" (Unit) (Put (Var "abc") (Int 1) (FAdd (FAdd (FMul (Var "ao") (App (Var "fsqr") ([Get (Var "cs_temp") (Int 1)]))) (FMul (Var "bo") (App (Var "fsqr") ([Get (Var "cs_temp") (Int 4)])))) (FMul (Var "co") (App (Var "fsqr") ([Get (Var "cs_temp") (Int 7)]))))) (Let "" (Unit) (Put (Var "abc") (Int 2) (FAdd (FAdd (FMul (Var "ao") (App (Var "fsqr") ([Get (Var "cs_temp") (Int 2)]))) (FMul (Var "bo") (App (Var "fsqr") ([Get (Var "cs_temp") (Int 5)])))) (FMul (Var "co") (App (Var "fsqr") ([Get (Var "cs_temp") (Int 8)]))))) (Let "" (Unit) (Put (Var "rotation") (Int 0) (FMul (Float 2.0) (FAdd (FAdd (FMul (FMul (Var "ao") (Get (Var "cs_temp") (Int 1))) (Get (Var "cs_temp") (Int 2))) (FMul (FMul (Var "bo") (Get (Var "cs_temp") (Int 4))) (Get (Var "cs_temp") (Int 5)))) (FMul (FMul (Var "co") (Get (Var "cs_temp") (Int 7))) (Get (Var "cs_temp") (Int 8)))))) (Let "" (Unit) (Put (Var "rotation") (Int 1) (FMul (Float 2.0) (FAdd (FAdd (FMul (FMul (Var "ao") (Get (Var "cs_temp") (Int 0))) (Get (Var "cs_temp") (Int 2))) (FMul (FMul (Var "bo") (Get (Var "cs_temp") (Int 3))) (Get (Var "cs_temp") (Int 5)))) (FMul (FMul (Var "co") (Get (Var "cs_temp") (Int 6))) (Get (Var "cs_temp") (Int 8)))))) (Put (Var "rotation") (Int 2) (FMul (Float 2.0) (FAdd (FAdd (FMul (FMul (Var "ao") (Get (Var "cs_temp") (Int 0))) (Get (Var "cs_temp") (Int 1))) (FMul (FMul (Var "bo") (Get (Var "cs_temp") (Int 3))) (Get (Var "cs_temp") (Int 4)))) (FMul (FMul (Var "co") (Get (Var "cs_temp") (Int 6))) (Get (Var "cs_temp") (Int 7))))))))))))))))))))))))))))) (Unit)) (Bool True))))))))))))))))))))))))))) (Bool False))) (LetRec "read_object" (Var 0) [("n", Var 0)] (If (Not (LE (Int 61) (Var "n"))) (If (App (Var "read_nth_object") ([Var "n"])) (App (Var "read_object") ([Add (Var "n") (Int 1)])) (Unit)) (Unit)) (LetRec "read_all_object" (Var 0) [("", Var 0)] (App (Var "read_object") ([Int 0])) (LetRec "read_net_item" (Var 0) [("length", Var 0)] (Let "item" (Var 0) (App (Var "read_int") ([Unit])) (If (Eq (Var "item") (Neg (Int 1))) (Array (Add (Var "length") (Int 1)) (Neg (Int 1))) (Let "v" (Var 0) (App (Var "read_net_item") ([Add (Var "length") (Int 1)])) (Let "" (Unit) (Put (Var "v") (Var "length") (Var "item")) (Var "v"))))) (LetRec "read_or_network" (Var 0) [("length", Var 0)] (Let "net" (Var 0) (App (Var "read_net_item") ([Int 0])) (If (Eq (Get (Var "net") (Int 0)) (Neg (Int 1))) (Array (Add (Var "length") (Int 1)) (Var "net")) (Let "v" (Var 0) (App (Var "read_or_network") ([Add (Var "length") (Int 1)])) (Let "" (Unit) (Put (Var "v") (Var "length") (Var "net")) (Var "v"))))) (LetRec "read_and_network" (Var 0) [("n", Var 0)] (Let "net" (Var 0) (App (Var "read_net_item") ([Int 0])) (If (Eq (Get (Var "net") (Int 0)) (Neg (Int 1))) (Unit) (Let "" (Unit) (Put (Var "and_net") (Var "n") (Var "net")) (App (Var "read_and_network") ([Add (Var "n") (Int 1)]))))) (LetRec "read_parameter" (Var 0) [("", Var 0)] (Let "" (Unit) (App (Var "read_environ") ([Unit])) (Let "" (Unit) (App (Var "read_all_object") ([Unit])) (Let "" (Unit) (App (Var "read_and_network") ([Int 0])) (Put (Var "or_net") (Int 0) (App (Var "read_or_network") ([Int 0])))))) (LetRec "solver_rect" (Var 0) [("m", Var 0), ("l", Var 0)] (Let "answera" (Var 0) (If (Eq (Float 0.0) (Get (Var "l") (Int 0))) (Bool False) (Let "d" (Var 0) (If (App (Var "xor") ([App (Var "o_isinvert") ([Var "m"]), Not (LE (Float 0.0) (Get (Var "l") (Int 0)))])) (App (Var "o_param_a") ([Var "m"])) (FNeg (App (Var "o_param_a") ([Var "m"])))) (Let "d2" (Var 0) (FDiv (FSub (Var "d") (Get (Var "solver_w_vec") (Int 0))) (Get (Var "l") (Int 0))) (If (Not (LE (App (Var "o_param_b") ([Var "m"])) (App (Var "abs_float") ([FAdd (FMul (Var "d2") (Get (Var "l") (Int 1))) (Get (Var "solver_w_vec") (Int 1))])))) (If (Not (LE (App (Var "o_param_c") ([Var "m"])) (App (Var "abs_float") ([FAdd (FMul (Var "d2") (Get (Var "l") (Int 2))) (Get (Var "solver_w_vec") (Int 2))])))) (Let "" (Unit) (Put (Var "solver_dist") (Int 0) (Var "d2")) (Bool True)) (Bool False)) (Bool False))))) (If (Var "answera") (Int 1) (Let "answerb" (Var 0) (If (Eq (Float 0.0) (Get (Var "l") (Int 1))) (Bool False) (Let "d" (Var 0) (If (App (Var "xor") ([App (Var "o_isinvert") ([Var "m"]), Not (LE (Float 0.0) (Get (Var "l") (Int 1)))])) (App (Var "o_param_b") ([Var "m"])) (FNeg (App (Var "o_param_b") ([Var "m"])))) (Let "d2" (Var 0) (FDiv (FSub (Var "d") (Get (Var "solver_w_vec") (Int 1))) (Get (Var "l") (Int 1))) (If (Not (LE (App (Var "o_param_c") ([Var "m"])) (App (Var "abs_float") ([FAdd (FMul (Var "d2") (Get (Var "l") (Int 2))) (Get (Var "solver_w_vec") (Int 2))])))) (If (Not (LE (App (Var "o_param_a") ([Var "m"])) (App (Var "abs_float") ([FAdd (FMul (Var "d2") (Get (Var "l") (Int 0))) (Get (Var "solver_w_vec") (Int 0))])))) (Let "" (Unit) (Put (Var "solver_dist") (Int 0) (Var "d2")) (Bool True)) (Bool False)) (Bool False))))) (If (Var "answerb") (Int 2) (Let "answerc" (Var 0) (If (Eq (Float 0.0) (Get (Var "l") (Int 2))) (Bool False) (Let "d" (Var 0) (If (App (Var "xor") ([App (Var "o_isinvert") ([Var "m"]), Not (LE (Float 0.0) (Get (Var "l") (Int 2)))])) (App (Var "o_param_c") ([Var "m"])) (FNeg (App (Var "o_param_c") ([Var "m"])))) (Let "d2" (Var 0) (FDiv (FSub (Var "d") (Get (Var "solver_w_vec") (Int 2))) (Get (Var "l") (Int 2))) (If (Not (LE (App (Var "o_param_a") ([Var "m"])) (App (Var "abs_float") ([FAdd (FMul (Var "d2") (Get (Var "l") (Int 0))) (Get (Var "solver_w_vec") (Int 0))])))) (If (Not (LE (App (Var "o_param_b") ([Var "m"])) (App (Var "abs_float") ([FAdd (FMul (Var "d2") (Get (Var "l") (Int 1))) (Get (Var "solver_w_vec") (Int 1))])))) (Let "" (Unit) (Put (Var "solver_dist") (Int 0) (Var "d2")) (Bool True)) (Bool False)) (Bool False))))) (If (Var "answerc") (Int 3) (Int 0))))))) (Unit))))))))))))))))))))))))))))))))))
let rec solver_surface m l = let q = (l.(0) *. o_param_a m +. l.(1) *. o_param_b m +. l.(2) *. o_param_c m) in if 0.0 < q then let t = (solver_w_vec.(0) *. o_param_a m +. solver_w_vec.(1) *. o_param_b m +. solver_w_vec.(2) *. o_param_c m) /. q in (solver_dist.(0) <- -.t; 1) else 0 in let rec in_prod_sqr_obj m v = ((fsqr v.(0)) *. o_param_a m +. (fsqr v.(1)) *. o_param_b m +. (fsqr v.(2)) *. o_param_c m) in let rec in_prod_co_objrot m v = v.(1) *. v.(2) *. o_param_r1 m +. v.(0) *. v.(2) *. o_param_r2 m +. v.(0) *. v.(1) *. o_param_r3 m in let rec solver2nd_mul_b m l = solver_w_vec.(0) *. l.(0) *. o_param_a m +. solver_w_vec.(1) *. l.(1) *. o_param_b m +. solver_w_vec.(2) *. l.(2) *. o_param_c m in let rec solver2nd_rot_b m l = (solver_w_vec.(2) *. l.(1) +. solver_w_vec.(1) *. l.(2)) *. o_param_r1 m +. (solver_w_vec.(0) *. l.(2) +. solver_w_vec.(2) *. l.(0)) *. o_param_r2 m +. (solver_w_vec.(0) *. l.(1) +. solver_w_vec.(1) *. l.(0)) *. o_param_r3 m in let rec solver_second m l = let aa0 = in_prod_sqr_obj m l in let aa = if o_isrot m <> 0 then aa0 +. in_prod_co_objrot m l else aa0 in if 0.0 = aa then 0 else ( let bb0 = 2.0 *. solver2nd_mul_b m l in let bb = if o_isrot m <> 0 then bb0 +. solver2nd_rot_b m l else bb0 in let cc0 = in_prod_sqr_obj m solver_w_vec in let cc1 = if o_isrot m <> 0 then (cc0 +. in_prod_co_objrot m solver_w_vec) else cc0 in let cc = if o_form m = 3 then cc1 -. 1.0 else cc1 in let d = let d2 = 4.0 *. aa *. cc in (fsqr bb) -. d2 in if 0.0 < d then ( let sd = sqrt d in let t1 = if o_isinvert m then sd else -.sd in (solver_dist.(0) <- ((t1 -. bb) /. 2.0 /. aa); 1)) else 0) in let rec solver index l p = let m = objects.(index) in solver_w_vec.(0) <- p.(0) -. o_param_x m; solver_w_vec.(1) <- p.(1) -. o_param_y m; solver_w_vec.(2) <- p.(2) -. o_param_z m; let m_shape = o_form m in if m_shape = 1 then solver_rect m l else if m_shape = 2 then solver_surface m l else solver_second m l in let rec is_rect_outside m = if (if abs_float isoutside_q.(0) < o_param_a m then if abs_float isoutside_q.(1) < o_param_b m then if abs_float isoutside_q.(2) < o_param_c m then true else false else false else false) then o_isinvert m else not (o_isinvert m) in let rec is_plane_outside m = let w = (o_param_a m *. isoutside_q.(0) +. o_param_b m *. isoutside_q.(1) +. o_param_c m *. isoutside_q.(2)) in let s = 0.0 > w in not (xor (o_isinvert m) s) in let rec is_second_outside m = let w = in_prod_sqr_obj m isoutside_q in let w2 = if o_form m = 3 then w -. 1.0 else w in let w3 = if o_isrot m <> 0 then w2 +. in_prod_co_objrot m isoutside_q else w2 in let s = 0.0 > w3 in not (xor (o_isinvert m) s) in let rec is_outside m = isoutside_q.(0) <- chkinside_p.(0) -. o_param_x m; isoutside_q.(1) <- chkinside_p.(1) -. o_param_y m; isoutside_q.(2) <- chkinside_p.(2) -. o_param_z m; let m_shape = o_form m in if m_shape = 1 then is_rect_outside m else if m_shape = 2 then is_plane_outside m else is_second_outside m in let rec check_all_inside ofs iand = let head = iand.(ofs) in if head = -1 then true else ( if (is_outside (objects.(head))) then false else check_all_inside (ofs + 1) iand) in let rec shadow_check_and_group iand_ofs and_group p = if and_group.(iand_ofs) = -1 then false else let obj = and_group.(iand_ofs) in let t0 = solver obj light p in let t0p = solver_dist.(0) in if (if t0 <> 0 then t0p < -0.2 else false) then let t = t0p +. 0.0 in chkinside_p.(0) <- light.(0) *. t +. p.(0); chkinside_p.(1) <- light.(1) *. t +. p.(1); chkinside_p.(2) <- light.(2) *. t +. p.(2); if (check_all_inside 0 and_group) then true else shadow_check_and_group (iand_ofs + 1) and_group p else if o_isinvert (objects.(obj)) then shadow_check_and_group (iand_ofs + 1) and_group p else false in let rec shadow_check_one_or_group ofs or_group p = let head = or_group.(ofs) in if head = -1 then false else ( let and_group = and_net.(head) in let shadow_p = shadow_check_and_group 0 and_group p in if shadow_p then true else shadow_check_one_or_group (ofs + 1) or_group p) in let rec shadow_check_one_or_matrix ofs or_matrix p = let head = or_matrix.(ofs) in let range_primitive = head.(0) in if range_primitive = -1 then false else ( if range_primitive = 99 then if (shadow_check_one_or_group 1 head p) then true else shadow_check_one_or_matrix (ofs + 1) or_matrix p else let t = solver range_primitive light p in if t <> 0 then if solver_dist.(0) < -0.1 then if shadow_check_one_or_group 1 head p then true else shadow_check_one_or_matrix (ofs + 1) or_matrix p else shadow_check_one_or_matrix (ofs + 1) or_matrix p else shadow_check_one_or_matrix (ofs + 1) or_matrix p) in let rec solve_each_element iand_ofs and_group = let iobj = and_group.(iand_ofs) in if iobj = -1 then () else ( let t0 = solver iobj vscan viewpoint in if t0 <> 0 then ( let t0p = solver_dist.(0) in if -0.1 < t0p then if t0p < tmin.(0) then ( let t = t0p +. 0.0 in chkinside_p.(0) <- vscan.(0) *. t +. viewpoint.(0); chkinside_p.(1) <- vscan.(1) *. t +. viewpoint.(1); chkinside_p.(2) <- vscan.(2) *. t +. viewpoint.(2); if check_all_inside 0 and_group then ( tmin.(0) <- t; crashed_point.(0) <- chkinside_p.(0); crashed_point.(1) <- chkinside_p.(1); crashed_point.(2) <- chkinside_p.(2); intsec_rectside.(0) <- t0; crashed_object.(0) <- iobj) else ()) else () else ()) else ( if o_isinvert (objects.(iobj)) then () else end_flag.(0) <- (true)); if (not (end_flag.(0))) then solve_each_element (iand_ofs + 1) and_group else ()) in let rec solve_one_or_network ofs or_group = let head = or_group.(ofs) in if head = -1 then () else ( let and_group = and_net.(head) in end_flag.(0) <- false; solve_each_element 0 and_group; solve_one_or_network (ofs + 1) or_group) in let rec trace_or_matrix ofs or_network = let head = or_network.(ofs) in let range_primitive = head.(0) in if range_primitive = -1 then () else ( if range_primitive = 99 then (solve_one_or_network 1 head) else ( let t = solver range_primitive vscan viewpoint in if t <> 0 then let tp = solver_dist.(0) in if tp < tmin.(0) then (solve_one_or_network 1 head) else () else ()); trace_or_matrix (ofs + 1) or_network) in let rec tracer viewpoint vscan = ( tmin.(0) <- (1000000000.0); trace_or_matrix 0 (or_net.(0)); let t = tmin.(0) in if -0.1 < t then if t < 100000000.0 then true else false else false) in let rec get_nvector_rect _ = let rectside = intsec_rectside.(0) in if rectside = 1 then ( nvector.(0) <- -.(sgn (vscan.(0))); nvector.(1) <- 0.0; nvector.(2) <- 0.0) else if rectside = 2 then ( nvector.(0) <- 0.0; nvector.(1) <- -.(sgn (vscan.(1))); nvector.(2) <- 0.0) else if rectside = 3 then ( nvector.(0) <- 0.0; nvector.(1) <- 0.0; nvector.(2) <- -.(sgn (vscan.(2)))) else () in let rec get_nvector_plane m = nvector.(0) <- -.(o_param_a m); nvector.(1) <- -.(o_param_b m); nvector.(2) <- -.(o_param_c m) in ()
LetRec "solver_surface" (Var 0) [("m", Var 0), ("l", Var 0)] (Let "q" (Var 0) (FAdd (FAdd (FMul (Get (Var "l") (Int 0)) (App (Var "o_param_a") ([Var "m"]))) (FMul (Get (Var "l") (Int 1)) (App (Var "o_param_b") ([Var "m"])))) (FMul (Get (Var "l") (Int 2)) (App (Var "o_param_c") ([Var "m"])))) (If (Not (LE (Var "q") (Float 0.0))) (Let "t" (Var 0) (FDiv (FAdd (FAdd (FMul (Get (Var "solver_w_vec") (Int 0)) (App (Var "o_param_a") ([Var "m"]))) (FMul (Get (Var "solver_w_vec") (Int 1)) (App (Var "o_param_b") ([Var "m"])))) (FMul (Get (Var "solver_w_vec") (Int 2)) (App (Var "o_param_c") ([Var "m"])))) (Var "q")) (Let "" (Unit) (Put (Var "solver_dist") (Int 0) (FNeg (Var "t"))) (Int 1))) (Int 0))) (LetRec "in_prod_sqr_obj" (Var 0) [("m", Var 0), ("v", Var 0)] (FAdd (FAdd (FMul (App (Var "fsqr") ([Get (Var "v") (Int 0)])) (App (Var "o_param_a") ([Var "m"]))) (FMul (App (Var "fsqr") ([Get (Var "v") (Int 1)])) (App (Var "o_param_b") ([Var "m"])))) (FMul (App (Var "fsqr") ([Get (Var "v") (Int 2)])) (App (Var "o_param_c") ([Var "m"])))) (LetRec "in_prod_co_objrot" (Var 0) [("m", Var 0), ("v", Var 0)] (FAdd (FAdd (FMul (FMul (Get (Var "v") (Int 1)) (Get (Var "v") (Int 2))) (App (Var "o_param_r1") ([Var "m"]))) (FMul (FMul (Get (Var "v") (Int 0)) (Get (Var "v") (Int 2))) (App (Var "o_param_r2") ([Var "m"])))) (FMul (FMul (Get (Var "v") (Int 0)) (Get (Var "v") (Int 1))) (App (Var "o_param_r3") ([Var "m"])))) (LetRec "solver2nd_mul_b" (Var 0) [("m", Var 0), ("l", Var 0)] (FAdd (FAdd (FMul (FMul (Get (Var "solver_w_vec") (Int 0)) (Get (Var "l") (Int 0))) (App (Var "o_param_a") ([Var "m"]))) (FMul (FMul (Get (Var "solver_w_vec") (Int 1)) (Get (Var "l") (Int 1))) (App (Var "o_param_b") ([Var "m"])))) (FMul (FMul (Get (Var "solver_w_vec") (Int 2)) (Get (Var "l") (Int 2))) (App (Var "o_param_c") ([Var "m"])))) (LetRec "solver2nd_rot_b" (Var 0) [("m", Var 0), ("l", Var 0)] (FAdd (FAdd (FMul (FAdd (FMul (Get (Var "solver_w_vec") (Int 2)) (Get (Var "l") (Int 1))) (FMul (Get (Var "solver_w_vec") (Int 1)) (Get (Var "l") (Int 2)))) (App (Var "o_param_r1") ([Var "m"]))) (FMul (FAdd (FMul (Get (Var "solver_w_vec") (Int 0)) (Get (Var "l") (Int 2))) (FMul (Get (Var "solver_w_vec") (Int 2)) (Get (Var "l") (Int 0)))) (App (Var "o_param_r2") ([Var "m"])))) (FMul (FAdd (FMul (Get (Var "solver_w_vec") (Int 0)) (Get (Var "l") (Int 1))) (FMul (Get (Var "solver_w_vec") (Int 1)) (Get (Var "l") (Int 0)))) (App (Var "o_param_r3") ([Var "m"])))) (LetRec "solver_second" (Var 0) [("m", Var 0), ("l", Var 0)] (Let "aa0" (Var 0) (App (Var "in_prod_sqr_obj") ([Var "m", Var "l"])) (Let "aa" (Var 0) (If (Not (Eq (App (Var "o_isrot") ([Var "m"])) (Int 0))) (FAdd (Var "aa0") (App (Var "in_prod_co_objrot") ([Var "m", Var "l"]))) (Var "aa0")) (If (Eq (Float 0.0) (Var "aa")) (Int 0) (Let "bb0" (Var 0) (FMul (Float 2.0) (App (Var "solver2nd_mul_b") ([Var "m", Var "l"]))) (Let "bb" (Var 0) (If (Not (Eq (App (Var "o_isrot") ([Var "m"])) (Int 0))) (FAdd (Var "bb0") (App (Var "solver2nd_rot_b") ([Var "m", Var "l"]))) (Var "bb0")) (Let "cc0" (Var 0) (App (Var "in_prod_sqr_obj") ([Var "m", Var "solver_w_vec"])) (Let "cc1" (Var 0) (If (Not (Eq (App (Var "o_isrot") ([Var "m"])) (Int 0))) (FAdd (Var "cc0") (App (Var "in_prod_co_objrot") ([Var "m", Var "solver_w_vec"]))) (Var "cc0")) (Let "cc" (Var 0) (If (Eq (App (Var "o_form") ([Var "m"])) (Int 3)) (FSub (Var "cc1") (Float 1.0)) (Var "cc1")) (Let "d" (Var 0) (Let "d2" (Var 0) (FMul (FMul (Float 4.0) (Var "aa")) (Var "cc")) (FSub (App (Var "fsqr") ([Var "bb"])) (Var "d2"))) (If (Not (LE (Var "d") (Float 0.0))) (Let "sd" (Var 0) (App (Var "sqrt") ([Var "d"])) (Let "t1" (Var 0) (If (App (Var "o_isinvert") ([Var "m"])) (Var "sd") (FNeg (Var "sd"))) (Let "" (Unit) (Put (Var "solver_dist") (Int 0) (FDiv (FDiv (FSub (Var "t1") (Var "bb")) (Float 2.0)) (Var "aa"))) (Int 1)))) (Int 0))))))))))) (LetRec "solver" (Var 0) [("index", Var 0), ("l", Var 0), ("p", Var 0)] (Let "m" (Var 0) (Get (Var "objects") (Var "index")) (Let "" (Unit) (Put (Var "solver_w_vec") (Int 0) (FSub (Get (Var "p") (Int 0)) (App (Var "o_param_x") ([Var "m"])))) (Let "" (Unit) (Put (Var "solver_w_vec") (Int 1) (FSub (Get (Var "p") (Int 1)) (App (Var "o_param_y") ([Var "m"])))) (Let "" (Unit) (Put (Var "solver_w_vec") (Int 2) (FSub (Get (Var "p") (Int 2)) (App (Var "o_param_z") ([Var "m"])))) (Let "m_shape" (Var 0) (App (Var "o_form") ([Var "m"])) (If (Eq (Var "m_shape") (Int 1)) (App (Var "solver_rect") ([Var "m", Var "l"])) (If (Eq (Var "m_shape") (Int 2)) (App (Var "solver_surface") ([Var "m", Var "l"])) (App (Var "solver_second") ([Var "m", Var "l"]))))))))) (LetRec "is_rect_outside" (Var 0) [("m", Var 0)] (If (If (Not (LE (App (Var "o_param_a") ([Var "m"])) (App (Var "abs_float") ([Get (Var "isoutside_q") (Int 0)])))) (If (Not (LE (App (Var "o_param_b") ([Var "m"])) (App (Var "abs_float") ([Get (Var "isoutside_q") (Int 1)])))) (If (Not (LE (App (Var "o_param_c") ([Var "m"])) (App (Var "abs_float") ([Get (Var "isoutside_q") (Int 2)])))) (Bool True) (Bool False)) (Bool False)) (Bool False)) (App (Var "o_isinvert") ([Var "m"])) (Not (App (Var "o_isinvert") ([Var "m"])))) (LetRec "is_plane_outside" (Var 0) [("m", Var 0)] (Let "w" (Var 0) (FAdd (FAdd (FMul (App (Var "o_param_a") ([Var "m"])) (Get (Var "isoutside_q") (Int 0))) (FMul (App (Var "o_param_b") ([Var "m"])) (Get (Var "isoutside_q") (Int 1)))) (FMul (App (Var "o_param_c") ([Var "m"])) (Get (Var "isoutside_q") (Int 2)))) (Let "s" (Var 0) (Not (LE (Float 0.0) (Var "w"))) (Not (App (Var "xor") ([App (Var "o_isinvert") ([Var "m"]), Var "s"]))))) (LetRec "is_second_outside" (Var 0) [("m", Var 0)] (Let "w" (Var 0) (App (Var "in_prod_sqr_obj") ([Var "m", Var "isoutside_q"])) (Let "w2" (Var 0) (If (Eq (App (Var "o_form") ([Var "m"])) (Int 3)) (FSub (Var "w") (Float 1.0)) (Var "w")) (Let "w3" (Var 0) (If (Not (Eq (App (Var "o_isrot") ([Var "m"])) (Int 0))) (FAdd (Var "w2") (App (Var "in_prod_co_objrot") ([Var "m", Var "isoutside_q"]))) (Var "w2")) (Let "s" (Var 0) (Not (LE (Float 0.0) (Var "w3"))) (Not (App (Var "xor") ([App (Var "o_isinvert") ([Var "m"]), Var "s"]))))))) (LetRec "is_outside" (Var 0) [("m", Var 0)] (Let "" (Unit) (Put (Var "isoutside_q") (Int 0) (FSub (Get (Var "chkinside_p") (Int 0)) (App (Var "o_param_x") ([Var "m"])))) (Let "" (Unit) (Put (Var "isoutside_q") (Int 1) (FSub (Get (Var "chkinside_p") (Int 1)) (App (Var "o_param_y") ([Var "m"])))) (Let "" (Unit) (Put (Var "isoutside_q") (Int 2) (FSub (Get (Var "chkinside_p") (Int 2)) (App (Var "o_param_z") ([Var "m"])))) (Let "m_shape" (Var 0) (App (Var "o_form") ([Var "m"])) (If (Eq (Var "m_shape") (Int 1)) (App (Var "is_rect_outside") ([Var "m"])) (If (Eq (Var "m_shape") (Int 2)) (App (Var "is_plane_outside") ([Var "m"])) (App (Var "is_second_outside") ([Var "m"])))))))) (LetRec "check_all_inside" (Var 0) [("ofs", Var 0), ("iand", Var 0)] (Let "head" (Var 0) (Get (Var "iand") (Var "ofs")) (If (Eq (Var "head") (Neg (Int 1))) (Bool True) (If (App (Var "is_outside") ([Get (Var "objects") (Var "head")])) (Bool False) (App (Var "check_all_inside") ([Add (Var "ofs") (Int 1), Var "iand"]))))) (LetRec "shadow_check_and_group" (Var 0) [("iand_ofs", Var 0), ("and_group", Var 0), ("p", Var 0)] (If (Eq (Get (Var "and_group") (Var "iand_ofs")) (Neg (Int 1))) (Bool False) (Let "obj" (Var 0) (Get (Var "and_group") (Var "iand_ofs")) (Let "t0" (Var 0) (App (Var "solver") ([Var "obj", Var "light", Var "p"])) (Let "t0p" (Var 0) (Get (Var "solver_dist") (Int 0)) (If (If (Not (Eq (Var "t0") (Int 0))) (Not (LE (Float -0.2) (Var "t0p"))) (Bool False)) (Let "t" (Var 0) (FAdd (Var "t0p") (Float 0.0)) (Let "" (Unit) (Put (Var "chkinside_p") (Int 0) (FAdd (FMul (Get (Var "light") (Int 0)) (Var "t")) (Get (Var "p") (Int 0)))) (Let "" (Unit) (Put (Var "chkinside_p") (Int 1) (FAdd (FMul (Get (Var "light") (Int 1)) (Var "t")) (Get (Var "p") (Int 1)))) (Let "" (Unit) (Put (Var "chkinside_p") (Int 2) (FAdd (FMul (Get (Var "light") (Int 2)) (Var "t")) (Get (Var "p") (Int 2)))) (If (App (Var "check_all_inside") ([Int 0, Var "and_group"])) (Bool True) (App (Var "shadow_check_and_group") ([Add (Var "iand_ofs") (Int 1), Var "and_group", Var "p"]))))))) (If (App (Var "o_isinvert") ([Get (Var "objects") (Var "obj")])) (App (Var "shadow_check_and_group") ([Add (Var "iand_ofs") (Int 1), Var "and_group", Var "p"])) (Bool False))))))) (LetRec "shadow_check_one_or_group" (Var 0) [("ofs", Var 0), ("or_group", Var 0), ("p", Var 0)] (Let "head" (Var 0) (Get (Var "or_group") (Var "ofs")) (If (Eq (Var "head") (Neg (Int 1))) (Bool False) (Let "and_group" (Var 0) (Get (Var "and_net") (Var "head")) (Let "shadow_p" (Var 0) (App (Var "shadow_check_and_group") ([Int 0, Var "and_group", Var "p"])) (If (Var "shadow_p") (Bool True) (App (Var "shadow_check_one_or_group") ([Add (Var "ofs") (Int 1), Var "or_group", Var "p"]))))))) (LetRec "shadow_check_one_or_matrix" (Var 0) [("ofs", Var 0), ("or_matrix", Var 0), ("p", Var 0)] (Let "head" (Var 0) (Get (Var "or_matrix") (Var "ofs")) (Let "range_primitive" (Var 0) (Get (Var "head") (Int 0)) (If (Eq (Var "range_primitive") (Neg (Int 1))) (Bool False) (If (Eq (Var "range_primitive") (Int 99)) (If (App (Var "shadow_check_one_or_group") ([Int 1, Var "head", Var "p"])) (Bool True) (App (Var "shadow_check_one_or_matrix") ([Add (Var "ofs") (Int 1), Var "or_matrix", Var "p"]))) (Let "t" (Var 0) (App (Var "solver") ([Var "range_primitive", Var "light", Var "p"])) (If (Not (Eq (Var "t") (Int 0))) (If (Not (LE (Float -0.1) (Get (Var "solver_dist") (Int 0)))) (If (App (Var "shadow_check_one_or_group") ([Int 1, Var "head", Var "p"])) (Bool True) (App (Var "shadow_check_one_or_matrix") ([Add (Var "ofs") (Int 1), Var "or_matrix", Var "p"]))) (App (Var "shadow_check_one_or_matrix") ([Add (Var "ofs") (Int 1), Var "or_matrix", Var "p"]))) (App (Var "shadow_check_one_or_matrix") ([Add (Var "ofs") (Int 1), Var "or_matrix", Var "p"])))))))) (LetRec "solve_each_element" (Var 0) [("iand_ofs", Var 0), ("and_group", Var 0)] (Let "iobj" (Var 0) (Get (Var "and_group") (Var "iand_ofs")) (If (Eq (Var "iobj") (Neg (Int 1))) (Unit) (Let "t0" (Var 0) (App (Var "solver") ([Var "iobj", Var "vscan", Var "viewpoint"])) (Let "" (Unit) (If (Not (Eq (Var "t0") (Int 0))) (Let "t0p" (Var 0) (Get (Var "solver_dist") (Int 0)) (If (Not (LE (Var "t0p") (Float -0.1))) (If (Not (LE (Get (Var "tmin") (Int 0)) (Var "t0p"))) (Let "t" (Var 0) (FAdd (Var "t0p") (Float 0.0)) (Let "" (Unit) (Put (Var "chkinside_p") (Int 0) (FAdd (FMul (Get (Var "vscan") (Int 0)) (Var "t")) (Get (Var "viewpoint") (Int 0)))) (Let "" (Unit) (Put (Var "chkinside_p") (Int 1) (FAdd (FMul (Get (Var "vscan") (Int 1)) (Var "t")) (Get (Var "viewpoint") (Int 1)))) (Let "" (Unit) (Put (Var "chkinside_p") (Int 2) (FAdd (FMul (Get (Var "vscan") (Int 2)) (Var "t")) (Get (Var "viewpoint") (Int 2)))) (If (App (Var "check_all_inside") ([Int 0, Var "and_group"])) (Let "" (Unit) (Put (Var "tmin") (Int 0) (Var "t")) (Let "" (Unit) (Put (Var "crashed_point") (Int 0) (Get (Var "chkinside_p") (Int 0))) (Let "" (Unit) (Put (Var "crashed_point") (Int 1) (Get (Var "chkinside_p") (Int 1))) (Let "" (Unit) (Put (Var "crashed_point") (Int 2) (Get (Var "chkinside_p") (Int 2))) (Let "" (Unit) (Put (Var "intsec_rectside") (Int 0) (Var "t0")) (Put (Var "crashed_object") (Int 0) (Var "iobj"))))))) (Unit)))))) (Unit)) (Unit))) (If (App (Var "o_isinvert") ([Get (Var "objects") (Var "iobj")])) (Unit) (Put (Var "end_flag") (Int 0) (Bool True)))) (If (Not (Get (Var "end_flag") (Int 0))) (App (Var "solve_each_element") ([Add (Var "iand_ofs") (Int 1), Var "and_group"])) (Unit)))))) (LetRec "solve_one_or_network" (Var 0) [("ofs", Var 0), ("or_group", Var 0)] (Let "head" (Var 0) (Get (Var "or_group") (Var "ofs")) (If (Eq (Var "head") (Neg (Int 1))) (Unit) (Let "and_group" (Var 0) (Get (Var "and_net") (Var "head")) (Let "" (Unit) (Put (Var "end_flag") (Int 0) (Bool False)) (Let "" (Unit) (App (Var "solve_each_element") ([Int 0, Var "and_group"])) (App (Var "solve_one_or_network") ([Add (Var "ofs") (Int 1), Var "or_group"]))))))) (LetRec "trace_or_matrix" (Var 0) [("ofs", Var 0), ("or_network", Var 0)] (Let "head" (Var 0) (Get (Var "or_network") (Var "ofs")) (Let "range_primitive" (Var 0) (Get (Var "head") (Int 0)) (If (Eq (Var "range_primitive") (Neg (Int 1))) (Unit) (Let "" (Unit) (If (Eq (Var "range_primitive") (Int 99)) (App (Var "solve_one_or_network") ([Int 1, Var "head"])) (Let "t" (Var 0) (App (Var "solver") ([Var "range_primitive", Var "vscan", Var "viewpoint"])) (If (Not (Eq (Var "t") (Int 0))) (Let "tp" (Var 0) (Get (Var "solver_dist") (Int 0)) (If (Not (LE (Get (Var "tmin") (Int 0)) (Var "tp"))) (App (Var "solve_one_or_network") ([Int 1, Var "head"])) (Unit))) (Unit)))) (App (Var "trace_or_matrix") ([Add (Var "ofs") (Int 1), Var "or_network"])))))) (LetRec "tracer" (Var 0) [("viewpoint", Var 0), ("vscan", Var 0)] (Let "" (Unit) (Put (Var "tmin") (Int 0) (Float 1000000000.0)) (Let "" (Unit) (App (Var "trace_or_matrix") ([Int 0, Get (Var "or_net") (Int 0)])) (Let "t" (Var 0) (Get (Var "tmin") (Int 0)) (If (Not (LE (Var "t") (Float -0.1))) (If (Not (LE (Float 100000000.0) (Var "t"))) (Bool True) (Bool False)) (Bool False))))) (LetRec "get_nvector_rect" (Var 0) [("", Var 0)] (Let "rectside" (Var 0) (Get (Var "intsec_rectside") (Int 0)) (If (Eq (Var "rectside") (Int 1)) (Let "" (Unit) (Put (Var "nvector") (Int 0) (FNeg (App (Var "sgn") ([Get (Var "vscan") (Int 0)])))) (Let "" (Unit) (Put (Var "nvector") (Int 1) (Float 0.0)) (Put (Var "nvector") (Int 2) (Float 0.0)))) (If (Eq (Var "rectside") (Int 2)) (Let "" (Unit) (Put (Var "nvector") (Int 0) (Float 0.0)) (Let "" (Unit) (Put (Var "nvector") (Int 1) (FNeg (App (Var "sgn") ([Get (Var "vscan") (Int 1)])))) (Put (Var "nvector") (Int 2) (Float 0.0)))) (If (Eq (Var "rectside") (Int 3)) (Let "" (Unit) (Put (Var "nvector") (Int 0) (Float 0.0)) (Let "" (Unit) (Put (Var "nvector") (Int 1) (Float 0.0)) (Put (Var "nvector") (Int 2) (FNeg (App (Var "sgn") ([Get (Var "vscan") (Int 2)])))))) (Unit))))) (LetRec "get_nvector_plane" (Var 0) [("m", Var 0)] (Let "" (Unit) (Put (Var "nvector") (Int 0) (FNeg (App (Var "o_param_a") ([Var "m"])))) (Let "" (Unit) (Put (Var "nvector") (Int 1) (FNeg (App (Var "o_param_b") ([Var "m"])))) (Put (Var "nvector") (Int 2) (FNeg (App (Var "o_param_c") ([Var "m"])))))) (Unit)))))))))))))))))))))
let rec raytracing nref energy = let crashed_p = tracer viewpoint vscan in if (not crashed_p) then if nref <> 0 then ( let hl = -.(in_prod vscan light) in if 0.0 < hl then ( let ihl = fsqr hl *. hl *. energy *. beam.(0) in rgb.(0) <- rgb.(0) +. ihl; rgb.(1) <- rgb.(1) +. ihl; rgb.(2) <- rgb.(2) +. ihl) else ()) else () else (); if crashed_p then ( let cobj = objects.(crashed_object.(0)) in get_nvector cobj crashed_point; let bright = if (shadow_check_one_or_matrix 0 or_net.(0) crashed_point) then 0.0 else ( let br = -.(in_prod nvector light) in let br1 = if 0.0 > br then 0.2 else br +. 0.2 in br1 *. energy *. o_diffuse cobj) in utexture cobj crashed_point; accumulate_vec_mul rgb texture_color bright; if nref > 4 then () else if 0.1 < energy then ( let w = (-2.0) *. in_prod vscan nvector in accumulate_vec_mul vscan nvector w; let m_surface = o_reflectiontype cobj in if m_surface = 1 then ( if 0.0 = (o_hilight cobj) then () else let hl = -.(in_prod vscan light) in if 0.0 < hl then ( let ihl = fsqr (fsqr hl) *. energy *. bright *. o_hilight cobj in rgb.(0) <- rgb.(0) +. ihl; rgb.(1) <- rgb.(1) +. ihl; rgb.(2) <- rgb.(2) +. ihl) else ()) else if m_surface = 2 then ( viewpoint.(0) <- crashed_point.(0); viewpoint.(1) <- crashed_point.(1); viewpoint.(2) <- crashed_point.(2); let energy2 = energy *. (1.0 -. o_diffuse cobj) in raytracing (nref + 1) energy2) else ()) else ()) else () in let rec write_rgb _ = ( let red = int_of_float rgb.(0) in let red = if red > 255 then 255 else red in print_byte red; let green = int_of_float rgb.(1) in let green = if green > 255 then 255 else green in print_byte green; let blue = int_of_float rgb.(2) in let blue = if blue > 255 then 255 else blue in print_byte blue) in let rec write_ppm_header _ = ( print_byte 80; print_byte (48 + 6); print_byte 10; print_int size.(0); print_byte 32; print_int size.(1); print_byte 10; print_int 255; print_byte 10) in let rec scan_point scanx = if scanx >= size.(0) then () else ( let sscanx = (float_of_int scanx -. scan_offset.(0)) *. scan_d.(0) in vscan.(0) <- (sscanx *. cos_v.(1) +. wscan.(0)); vscan.(1) <- (scan_sscany.(0) *. cos_v.(0) -. vp.(1)); vscan.(2) <- (-.sscanx *. sin_v.(1) +. wscan.(2)); let metric = sqrt ((fsqr sscanx) +. scan_met1.(0)) in vscan.(0) <- vscan.(0) /. metric; vscan.(1) <- vscan.(1) /. metric; vscan.(2) <- vscan.(2) /. metric; viewpoint.(0) <- view.(0); viewpoint.(1) <- view.(1); viewpoint.(2) <- view.(2); rgb.(0) <- 0.0; rgb.(1) <- 0.0; rgb.(2) <- 0.0; raytracing 0 1.0; write_rgb (); scan_point (scanx + 1)) in let rec scan_line scany = if scany < size.(0) then ( scan_sscany.(0) <- ( let t = (scan_offset.(0) -. 1.0 -. float_of_int scany) in scan_d.(0) *. t); scan_met1.(0) <- fsqr scan_sscany.(0) +. 40000.0; let t1 = scan_sscany.(0) *. sin_v.(0) in wscan.(0) <- t1 *. sin_v.(1) -. vp.(0); wscan.(2) <- t1 *. cos_v.(1) -. vp.(2); scan_point 0; scan_line (scany + 1)) else () in let rec scan_start _ = ( write_ppm_header (); let sizex = float_of_int size.(0) in scan_d.(0) <- 128.0 /. sizex; scan_offset.(0) <- sizex /. 2.0; scan_line 0) in let rec rt size_x size_y debug_p = ( size.(0) <- size_x; size.(1) <- size_y; dbg.(0) <- debug_p; read_parameter (); scan_start ()) in rt 768 768 false
LetRec "raytracing" (Var 0) [("nref", Var 0), ("energy", Var 0)] (Let "crashed_p" (Var 0) (App (Var "tracer") ([Var "viewpoint", Var "vscan"])) (Let "" (Unit) (If (Not (Var "crashed_p")) (If (Not (Eq (Var "nref") (Int 0))) (Let "hl" (Var 0) (FNeg (App (Var "in_prod") ([Var "vscan", Var "light"]))) (If (Not (LE (Var "hl") (Float 0.0))) (Let "ihl" (Var 0) (FMul (FMul (FMul (App (Var "fsqr") ([Var "hl"])) (Var "hl")) (Var "energy")) (Get (Var "beam") (Int 0))) (Let "" (Unit) (Put (Var "rgb") (Int 0) (FAdd (Get (Var "rgb") (Int 0)) (Var "ihl"))) (Let "" (Unit) (Put (Var "rgb") (Int 1) (FAdd (Get (Var "rgb") (Int 1)) (Var "ihl"))) (Put (Var "rgb") (Int 2) (FAdd (Get (Var "rgb") (Int 2)) (Var "ihl")))))) (Unit))) (Unit)) (Unit)) (If (Var "crashed_p") (Let "cobj" (Var 0) (Get (Var "objects") (Get (Var "crashed_object") (Int 0))) (Let "" (Unit) (App (Var "get_nvector") ([Var "cobj", Var "crashed_point"])) (Let "bright" (Var 0) (If (App (Var "shadow_check_one_or_matrix") ([Int 0, Get (Var "or_net") (Int 0), Var "crashed_point"])) (Float 0.0) (Let "br" (Var 0) (FNeg (App (Var "in_prod") ([Var "nvector", Var "light"]))) (Let "br1" (Var 0) (If (Not (LE (Float 0.0) (Var "br"))) (Float 0.2) (FAdd (Var "br") (Float 0.2))) (FMul (FMul (Var "br1") (Var "energy")) (App (Var "o_diffuse") ([Var "cobj"])))))) (Let "" (Unit) (App (Var "utexture") ([Var "cobj", Var "crashed_point"])) (Let "" (Unit) (App (Var "accumulate_vec_mul") ([Var "rgb", Var "texture_color", Var "bright"])) (If (Not (LE (Var "nref") (Int 4))) (Unit) (If (Not (LE (Var "energy") (Float 0.1))) (Let "w" (Var 0) (FMul (Float -2.0) (App (Var "in_prod") ([Var "vscan", Var "nvector"]))) (Let "" (Unit) (App (Var "accumulate_vec_mul") ([Var "vscan", Var "nvector", Var "w"])) (Let "m_surface" (Var 0) (App (Var "o_reflectiontype") ([Var "cobj"])) (If (Eq (Var "m_surface") (Int 1)) (If (Eq (Float 0.0) (App (Var "o_hilight") ([Var "cobj"]))) (Unit) (Let "hl" (Var 0) (FNeg (App (Var "in_prod") ([Var "vscan", Var "light"]))) (If (Not (LE (Var "hl") (Float 0.0))) (Let "ihl" (Var 0) (FMul (FMul (FMul (App (Var "fsqr") ([App (Var "fsqr") ([Var "hl"])])) (Var "energy")) (Var "bright")) (App (Var "o_hilight") ([Var "cobj"]))) (Let "" (Unit) (Put (Var "rgb") (Int 0) (FAdd (Get (Var "rgb") (Int 0)) (Var "ihl"))) (Let "" (Unit) (Put (Var "rgb") (Int 1) (FAdd (Get (Var "rgb") (Int 1)) (Var "ihl"))) (Put (Var "rgb") (Int 2) (FAdd (Get (Var "rgb") (Int 2)) (Var "ihl")))))) (Unit)))) (If (Eq (Var "m_surface") (Int 2)) (Let "" (Unit) (Put (Var "viewpoint") (Int 0) (Get (Var "crashed_point") (Int 0))) (Let "" (Unit) (Put (Var "viewpoint") (Int 1) (Get (Var "crashed_point") (Int 1))) (Let "" (Unit) (Put (Var "viewpoint") (Int 2) (Get (Var "crashed_point") (Int 2))) (Let "energy2" (Var 0) (FMul (Var "energy") (FSub (Float 1.0) (App (Var "o_diffuse") ([Var "cobj"])))) (App (Var "raytracing") ([Add (Var "nref") (Int 1), Var "energy2"])))))) (Unit)))))) (Unit)))))))) (Unit)))) (LetRec "write_rgb" (Var 0) [("", Var 0)] (Let "red" (Var 0) (App (Var "int_of_float") ([Get (Var "rgb") (Int 0)])) (Let "red" (Var 0) (If (Not (LE (Var "red") (Int 255))) (Int 255) (Var "red")) (Let "" (Unit) (App (Var "print_byte") ([Var "red"])) (Let "green" (Var 0) (App (Var "int_of_float") ([Get (Var "rgb") (Int 1)])) (Let "green" (Var 0) (If (Not (LE (Var "green") (Int 255))) (Int 255) (Var "green")) (Let "" (Unit) (App (Var "print_byte") ([Var "green"])) (Let "blue" (Var 0) (App (Var "int_of_float") ([Get (Var "rgb") (Int 2)])) (Let "blue" (Var 0) (If (Not (LE (Var "blue") (Int 255))) (Int 255) (Var "blue")) (App (Var "print_byte") ([Var "blue"])))))))))) (LetRec "write_ppm_header" (Var 0) [("", Var 0)] (Let "" (Unit) (App (Var "print_byte") ([Int 80])) (Let "" (Unit) (App (Var "print_byte") ([Add (Int 48) (Int 6)])) (Let "" (Unit) (App (Var "print_byte") ([Int 10])) (Let "" (Unit) (App (Var "print_int") ([Get (Var "size") (Int 0)])) (Let "" (Unit) (App (Var "print_byte") ([Int 32])) (Let "" (Unit) (App (Var "print_int") ([Get (Var "size") (Int 1)])) (Let "" (Unit) (App (Var "print_byte") ([Int 10])) (Let "" (Unit) (App (Var "print_int") ([Int 255])) (App (Var "print_byte") ([Int 10])))))))))) (LetRec "scan_point" (Var 0) [("scanx", Var 0)] (If (LE (Get (Var "size") (Int 0)) (Var "scanx")) (Unit) (Let "sscanx" (Var 0) (FMul (FSub (App (Var "float_of_int") ([Var "scanx"])) (Get (Var "scan_offset") (Int 0))) (Get (Var "scan_d") (Int 0))) (Let "" (Unit) (Put (Var "vscan") (Int 0) (FAdd (FMul (Var "sscanx") (Get (Var "cos_v") (Int 1))) (Get (Var "wscan") (Int 0)))) (Let "" (Unit) (Put (Var "vscan") (Int 1) (FSub (FMul (Get (Var "scan_sscany") (Int 0)) (Get (Var "cos_v") (Int 0))) (Get (Var "vp") (Int 1)))) (Let "" (Unit) (Put (Var "vscan") (Int 2) (FAdd (FMul (FNeg (Var "sscanx")) (Get (Var "sin_v") (Int 1))) (Get (Var "wscan") (Int 2)))) (Let "metric" (Var 0) (App (Var "sqrt") ([FAdd (App (Var "fsqr") ([Var "sscanx"])) (Get (Var "scan_met1") (Int 0))])) (Let "" (Unit) (Put (Var "vscan") (Int 0) (FDiv (Get (Var "vscan") (Int 0)) (Var "metric"))) (Let "" (Unit) (Put (Var "vscan") (Int 1) (FDiv (Get (Var "vscan") (Int 1)) (Var "metric"))) (Let "" (Unit) (Put (Var "vscan") (Int 2) (FDiv (Get (Var "vscan") (Int 2)) (Var "metric"))) (Let "" (Unit) (Put (Var "viewpoint") (Int 0) (Get (Var "view") (Int 0))) (Let "" (Unit) (Put (Var "viewpoint") (Int 1) (Get (Var "view") (Int 1))) (Let "" (Unit) (Put (Var "viewpoint") (Int 2) (Get (Var "view") (Int 2))) (Let "" (Unit) (Put (Var "rgb") (Int 0) (Float 0.0)) (Let "" (Unit) (Put (Var "rgb") (Int 1) (Float 0.0)) (Let "" (Unit) (Put (Var "rgb") (Int 2) (Float 0.0)) (Let "" (Unit) (App (Var "raytracing") ([Int 0, Float 1.0])) (Let "" (Unit) (App (Var "write_rgb") ([Unit])) (App (Var "scan_point") ([Add (Var "scanx") (Int 1)]))))))))))))))))))) (LetRec "scan_line" (Var 0) [("scany", Var 0)] (If (Not (LE (Get (Var "size") (Int 0)) (Var "scany"))) (Let "" (Unit) (Put (Var "scan_sscany") (Int 0) (Let "t" (Var 0) (FSub (FSub (Get (Var "scan_offset") (Int 0)) (Float 1.0)) (App (Var "float_of_int") ([Var "scany"]))) (FMul (Get (Var "scan_d") (Int 0)) (Var "t")))) (Let "" (Unit) (Put (Var "scan_met1") (Int 0) (FAdd (App (Var "fsqr") ([Get (Var "scan_sscany") (Int 0)])) (Float 40000.0))) (Let "t1" (Var 0) (FMul (Get (Var "scan_sscany") (Int 0)) (Get (Var "sin_v") (Int 0))) (Let "" (Unit) (Put (Var "wscan") (Int 0) (FSub (FMul (Var "t1") (Get (Var "sin_v") (Int 1))) (Get (Var "vp") (Int 0)))) (Let "" (Unit) (Put (Var "wscan") (Int 2) (FSub (FMul (Var "t1") (Get (Var "cos_v") (Int 1))) (Get (Var "vp") (Int 2)))) (Let "" (Unit) (App (Var "scan_point") ([Int 0])) (App (Var "scan_line") ([Add (Var "scany") (Int 1)])))))))) (Unit)) (LetRec "scan_start" (Var 0) [("", Var 0)] (Let "" (Unit) (App (Var "write_ppm_header") ([Unit])) (Let "sizex" (Var 0) (App (Var "float_of_int") ([Get (Var "size") (Int 0)])) (Let "" (Unit) (Put (Var "scan_d") (Int 0) (FDiv (Float 128.0) (Var "sizex"))) (Let "" (Unit) (Put (Var "scan_offset") (Int 0) (FDiv (Var "sizex") (Float 2.0))) (App (Var "scan_line") ([Int 0])))))) (LetRec "rt" (Var 0) [("size_x", Var 0), ("size_y", Var 0), ("debug_p", Var 0)] (Let "" (Unit) (Put (Var "size") (Int 0) (Var "size_x")) (Let "" (Unit) (Put (Var "size") (Int 1) (Var "size_y")) (Let "" (Unit) (Put (Var "dbg") (Int 0) (Var "debug_p")) (Let "" (Unit) (App (Var "read_parameter") ([Unit])) (App (Var "scan_start") ([Unit])))))) (App (Var "rt") ([Int 768, Int 768, Bool False]))))))))
let rec get_nvector_second_norot m p = nvector.(0) <- (p.(0) -. o_param_x m) *. o_param_a m; nvector.(1) <- (p.(1) -. o_param_y m) *. o_param_b m; nvector.(2) <- (p.(2) -. o_param_z m) *. o_param_c m; normalize_vector nvector (o_isinvert m) in let rec get_nvector_second_rot m p = nvector_w.(0) <- p.(0) -. o_param_x m; nvector_w.(1) <- p.(1) -. o_param_y m; nvector_w.(2) <- p.(2) -. o_param_z m; nvector.(0) <- (nvector_w.(0)        *. o_param_a m +. fhalf (nvector_w.(1) *. o_param_r3 m +. nvector_w.(2) *. o_param_r2 m)); nvector.(1) <- (nvector_w.(1)        *. o_param_b m +. fhalf (nvector_w.(0) *. o_param_r3 m +. nvector_w.(2) *. o_param_r1 m)); nvector.(2) <- (nvector_w.(2)        *. o_param_c m +. fhalf (nvector_w.(0) *. o_param_r2 m +. nvector_w.(1) *. o_param_r1 m)); normalize_vector nvector (o_isinvert m) in let rec get_nvector m p = let m_shape = o_form m in if m_shape = 1 then get_nvector_rect () else if m_shape = 2 then get_nvector_plane m else if o_isrot m <> 0 then get_nvector_second_rot m p else get_nvector_second_norot m p in ()
LetRec "get_nvector_second_norot" (Var 0) [("m", Var 0), ("p", Var 0)] (Let "" (Unit) (Put (Var "nvector") (Int 0) (FMul (FSub (Get (Var "p") (Int 0)) (App (Var "o_param_x") ([Var "m"]))) (App (Var "o_param_a") ([Var "m"])))) (Let "" (Unit) (Put (Var "nvector") (Int 1) (FMul (FSub (Get (Var "p") (Int 1)) (App (Var "o_param_y") ([Var "m"]))) (App (Var "o_param_b") ([Var "m"])))) (Let "" (Unit) (Put (Var "nvector") (Int 2) (FMul (FSub (Get (Var "p") (Int 2)) (App (Var "o_param_z") ([Var "m"]))) (App (Var "o_param_c") ([Var "m"])))) (App (Var "normalize_vector") ([Var "nvector", App (Var "o_isinvert") ([Var "m"])]))))) (LetRec "get_nvector_second_rot" (Var 0) [("m", Var 0), ("p", Var 0)] (Let "" (Unit) (Put (Var "nvector_w") (Int 0) (FSub (Get (Var "p") (Int 0)) (App (Var "o_param_x") ([Var "m"])))) (Let "" (Unit) (Put (Var "nvector_w") (Int 1) (FSub (Get (Var "p") (Int 1)) (App (Var "o_param_y") ([Var "m"])))) (Let "" (Unit) (Put (Var "nvector_w") (Int 2) (FSub (Get (Var "p") (Int 2)) (App (Var "o_param_z") ([Var "m"])))) (Let "" (Unit) (Put (Var "nvector") (Int 0) (FAdd (FMul (Get (Var "nvector_w") (Int 0)) (App (Var "o_param_a") ([Var "m"]))) (App (Var "fhalf") ([FAdd (FMul (Get (Var "nvector_w") (Int 1)) (App (Var "o_param_r3") ([Var "m"]))) (FMul (Get (Var "nvector_w") (Int 2)) (App (Var "o_param_r2") ([Var "m"])))])))) (Let "" (Unit) (Put (Var "nvector") (Int 1) (FAdd (FMul (Get (Var "nvector_w") (Int 1)) (App (Var "o_param_b") ([Var "m"]))) (App (Var "fhalf") ([FAdd (FMul (Get (Var "nvector_w") (Int 0)) (App (Var "o_param_r3") ([Var "m"]))) (FMul (Get (Var "nvector_w") (Int 2)) (App (Var "o_param_r1") ([Var "m"])))])))) (Let "" (Unit) (Put (Var "nvector") (Int 2) (FAdd (FMul (Get (Var "nvector_w") (Int 2)) (App (Var "o_param_c") ([Var "m"]))) (App (Var "fhalf") ([FAdd (FMul (Get (Var "nvector_w") (Int 0)) (App (Var "o_param_r2") ([Var "m"]))) (FMul (Get (Var "nvector_w") (Int 1)) (App (Var "o_param_r1") ([Var "m"])))])))) (App (Var "normalize_vector") ([Var "nvector", App (Var "o_isinvert") ([Var "m"])])))))))) (LetRec "get_nvector" (Var 0) [("m", Var 0), ("p", Var 0)] (Let "m_shape" (Var 0) (App (Var "o_form") ([Var "m"])) (If (Eq (Var "m_shape") (Int 1)) (App (Var "get_nvector_rect") ([Unit])) (If (Eq (Var "m_shape") (Int 2)) (App (Var "get_nvector_plane") ([Var "m"])) (If (Not (Eq (App (Var "o_isrot") ([Var "m"])) (Int 0))) (App (Var "get_nvector_second_rot") ([Var "m", Var "p"])) (App (Var "get_nvector_second_norot") ([Var "m", Var "p"])))))) (Unit)))
let rec in_prod v1 v2 = v1.(0) *. v2.(0) +. v1.(1) *. v2.(1) +. v1.(2) *. v2.(2) in let rec accumulate_vec_mul v1 v2 w = v1.(0) <- v1.(0) +. w *. v2.(0); v1.(1) <- v1.(1) +. w *. v2.(1); v1.(2) <- v1.(2) +. w *. v2.(2) in ()
LetRec "in_prod" (Var 0) [("v1", Var 0), ("v2", Var 0)] (FAdd (FAdd (FMul (Get (Var "v1") (Int 0)) (Get (Var "v2") (Int 0))) (FMul (Get (Var "v1") (Int 1)) (Get (Var "v2") (Int 1)))) (FMul (Get (Var "v1") (Int 2)) (Get (Var "v2") (Int 2)))) (LetRec "accumulate_vec_mul" (Var 0) [("v1", Var 0), ("v2", Var 0), ("w", Var 0)] (Let "" (Unit) (Put (Var "v1") (Int 0) (FAdd (Get (Var "v1") (Int 0)) (FMul (Var "w") (Get (Var "v2") (Int 0))))) (Let "" (Unit) (Put (Var "v1") (Int 1) (FAdd (Get (Var "v1") (Int 1)) (FMul (Var "w") (Get (Var "v2") (Int 1))))) (Put (Var "v1") (Int 2) (FAdd (Get (Var "v1") (Int 2)) (FMul (Var "w") (Get (Var "v2") (Int 2))))))) (Unit))
(let w1 = p.(0) -. o_param_x m in let flag1 = let d1 = (floor (w1 *. 0.0)) *. 20.0 in if w1 -. d1 < 10.0 then true else false in let w3 = p.(2) -. o_param_z m in let flag2 = let d2 = (floor (w3 *. 0.0)) *. 20.0 in if w3 -. d2 < 10.0 then true else false in texture_color.(1) <- if flag1 then (if flag2 then 255.0 else 0.0) else (if flag2 then 0.0 else 255.0))
Let "w1" (Var 0) (FSub (Get (Var "p") (Int 0)) (App (Var "o_param_x") ([Var "m"]))) (Let "flag1" (Var 0) (Let "d1" (Var 0) (FMul (App (Var "floor") ([FMul (Var "w1") (Float 0.0)])) (Float 20.0)) (If (Not (LE (Float 10.0) (FSub (Var "w1") (Var "d1")))) (Bool True) (Bool False))) (Let "w3" (Var 0) (FSub (Get (Var "p") (Int 2)) (App (Var "o_param_z") ([Var "m"]))) (Let "flag2" (Var 0) (Let "d2" (Var 0) (FMul (App (Var "floor") ([FMul (Var "w3") (Float 0.0)])) (Float 20.0)) (If (Not (LE (Float 10.0) (FSub (Var "w3") (Var "d2")))) (Bool True) (Bool False))) (Put (Var "texture_color") (Int 1) (If (Var "flag1") (If (Var "flag2") (Float 255.0) (Float 0.0)) (If (Var "flag2") (Float 0.0) (Float 255.0)))))))
let w2 = fsqr (sin (p.(1) *. 0.2)) in texture_color.(0) <- 255.0 *. w2; texture_color.(1) <- 255.0 *. (1.0 -. w2)
Let "w2" (Var 0) (App (Var "fsqr") ([App (Var "sin") ([FMul (Get (Var "p") (Int 1)) (Float 0.2)])])) (Let "" (Unit) (Put (Var "texture_color") (Int 0) (FMul (Float 255.0) (Var "w2"))) (Put (Var "texture_color") (Int 1) (FMul (Float 255.0) (FSub (Float 1.0) (Var "w2")))))
(let w1 = p.(0) -. o_param_x m in let w3 = p.(2) -. o_param_z m in let w2 = sqrt (fsqr w1 +. fsqr w3) /. 10.0 in let w4 =  (w2 -. floor w2) *. 3.1 in let cws = fsqr (cos w4) in texture_color.(1) <- cws *. 255.0; texture_color.(2) <- (1.0 -. cws) *. 255.0)
Let "w1" (Var 0) (FSub (Get (Var "p") (Int 0)) (App (Var "o_param_x") ([Var "m"]))) (Let "w3" (Var 0) (FSub (Get (Var "p") (Int 2)) (App (Var "o_param_z") ([Var "m"]))) (Let "w2" (Var 0) (FDiv (App (Var "sqrt") ([FAdd (App (Var "fsqr") ([Var "w1"])) (App (Var "fsqr") ([Var "w3"]))])) (Float 10.0)) (Let "w4" (Var 0) (FMul (FSub (Var "w2") (App (Var "floor") ([Var "w2"]))) (Float 3.1)) (Let "cws" (Var 0) (App (Var "fsqr") ([App (Var "cos") ([Var "w4"])])) (Let "" (Unit) (Put (Var "texture_color") (Int 1) (FMul (Var "cws") (Float 255.0))) (Put (Var "texture_color") (Int 2) (FMul (FSub (Float 1.0) (Var "cws")) (Float 255.0))))))))
let rec utexture m p = let m_tex = o_texturetype m in texture_color.(0) <- o_color_red m; texture_color.(1) <- o_color_green m; texture_color.(2) <- o_color_blue m; if m_tex = 1 then () else if m_tex = 2 then () else if m_tex = 3 then () else if m_tex = 4 then () else () in ()
LetRec "utexture" (Var 0) [("m", Var 0), ("p", Var 0)] (Let "m_tex" (Var 0) (App (Var "o_texturetype") ([Var "m"])) (Let "" (Unit) (Put (Var "texture_color") (Int 0) (App (Var "o_color_red") ([Var "m"]))) (Let "" (Unit) (Put (Var "texture_color") (Int 1) (App (Var "o_color_green") ([Var "m"]))) (Let "" (Unit) (Put (Var "texture_color") (Int 2) (App (Var "o_color_blue") ([Var "m"]))) (If (Eq (Var "m_tex") (Int 1)) (Unit) (If (Eq (Var "m_tex") (Int 2)) (Unit) (If (Eq (Var "m_tex") (Int 3)) (Unit) (If (Eq (Var "m_tex") (Int 4)) (Unit) (Unit))))))))) (Unit)
let w4 = sqrt ((fsqr w1) +. (fsqr w3)) in let w7 = if abs_float w1 < 1.0 then 15.0 else let w5 = abs_float (w3 /. w1) in (atan w5) *. (30.0 /. 3.1 ) in let w9 = w7 -. (floor w7) in let w2 = (p.(1) -. o_param_y m) *. (sqrt (o_param_b m)) in let w8 = if abs_float w7 < 1.0 then 15.0 else let w6 = abs_float (w2 /. w4) in (atan w6) *. (30.0 /. 3.1 ) in let w10 = w8 -. (floor w8) in let w11 = 0.1  -. (fsqr (0.5 -. w9)) -. (fsqr (0.5 -. w10)) in texture_color.(2) <- if 0.0 >= w11 then 0.0 else w11 *. (255.0 /. 0.3)
Let "w4" (Var 0) (App (Var "sqrt") ([FAdd (App (Var "fsqr") ([Var "w1"])) (App (Var "fsqr") ([Var "w3"]))])) (Let "w7" (Var 0) (If (Not (LE (Float 1.0) (App (Var "abs_float") ([Var "w1"])))) (Float 15.0) (Let "w5" (Var 0) (App (Var "abs_float") ([FDiv (Var "w3") (Var "w1")])) (FMul (App (Var "atan") ([Var "w5"])) (FDiv (Float 30.0) (Float 3.1))))) (Let "w9" (Var 0) (FSub (Var "w7") (App (Var "floor") ([Var "w7"]))) (Let "w2" (Var 0) (FMul (FSub (Get (Var "p") (Int 1)) (App (Var "o_param_y") ([Var "m"]))) (App (Var "sqrt") ([App (Var "o_param_b") ([Var "m"])]))) (Let "w8" (Var 0) (If (Not (LE (Float 1.0) (App (Var "abs_float") ([Var "w7"])))) (Float 15.0) (Let "w6" (Var 0) (App (Var "abs_float") ([FDiv (Var "w2") (Var "w4")])) (FMul (App (Var "atan") ([Var "w6"])) (FDiv (Float 30.0) (Float 3.1))))) (Let "w10" (Var 0) (FSub (Var "w8") (App (Var "floor") ([Var "w8"]))) (Let "w11" (Var 0) (FSub (FSub (Float 0.1) (App (Var "fsqr") ([FSub (Float 0.5) (Var "w9")]))) (App (Var "fsqr") ([FSub (Float 0.5) (Var "w10")]))) (Put (Var "texture_color") (Int 2) (If (LE (Var "w11") (Float 0.0)) (Float 0.0) (FMul (Var "w11") (FDiv (Float 255.0) (Float 0.3)))))))))))
%
